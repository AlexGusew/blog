---
title: Algorithms cheat sheet
description: A quick reference guide to some of the most commonly used algorithms
date: "2024-10-28"
---

<details>
<summary>

### Table of contents

</summary>

- [Two pointers](#two-pointers)
- [Sliding window](#sliding-window)
- [Greedy](#greedy)
- [Dijkstra's shortest path](#dijkstras-shortest-path)
- [Dynamic Programming](#dynamic-programming)
- [Traversals](#traversals)
- [Matrix](#matrix)
- [Bonus](#bonus)

</details>

<details>
<summary>

### Definitions

</summary>

- **Search Space Tree** - tree of possible solutions generated on each iteration of algorithm. It's useful to think of your problem as Search-Space tree.

</details>

## Two pointers

<AlgorithmSummary tc={{ latex: "$$O(n)$$" }} sc={{ latex: "$$O(1)$$" }} />

Iterating two pointers across an array to search for a pair of indices satisfying some condition in linear time.

#### Use cases

- Sequential data structure (arrays, linked lists)
- Process pairs
- Remove duplicates from a sorted data
- Detect cycle in array
- Find a pair, triplet, or a subarray that satisfies a specific condition
- Reversing, partitioning, swapping, or rearranging

#### Types

- Opposite directional

  - <ProblemBadge difficulty="Medium" /> [167. Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/)
  - <ProblemBadge difficulty="Hard" /> [42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/description/)

- Same directional

  - <ProblemBadge difficulty="Easy" /> [26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)

- Fast and slow pointers
  - <ProblemBadge difficulty="Easy" /> [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/description/)
  - <ProblemBadge difficulty="Easy" /> [876. Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/description/)

<details>
<summary>

#### Problem examples

</summary>

<br />

<Problem
  title="167. Two Sum II - Input Array Is Sorted"
  link="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description"
  difficulty="Medium"
>

Given a 1-indexed array of integers `numbers` that is already sorted in non-decreasing order, find two numbers such that they add up to a specific `target` number.

</Problem>

```py filename="167. Two Sum II - Input Array Is Sorted"
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        low = 0
        high = len(numbers) - 1
        while low < high:
            sum = numbers[low] + numbers[high]

            if sum == target:
                return [low + 1, high + 1]
            elif sum < target:
                low += 1
            else:
                high -= 1
        return [-1, -1]
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

---

<Problem
  title="876. Middle of the Linked List"
  link="https://leetcode.com/problems/middle-of-the-linked-list/description"
  difficulty="Easy"
>

Given the `head` of a singly linked list, return the middle node of the linked list.

If there are two middle nodes, return the second middle node.

</Problem>

```py filename="876. Middle of the Linked List"
class Solution:
    def middleNode(self, head):
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

---

<Problem
  title="42. Trapping Rain Water"
  link="https://leetcode.com/problems/trapping-rain-water/description"
  difficulty="Hard"
>

Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.

</Problem>

<Image
  src="/algorithms-cheatsheet/rain-water.png"
  width="718"
  height="404"
  alt="Trapping Rain Water example"
  priority={true}
/>

```py filename="42. Trapping Rain Water"
class Solution:
    def trap(self, height: List[int]) -> int:
        left, right = 0, len(height) - 1
        ans = 0
        left_max, right_max = 0, 0
        while left < right:
            if height[left] < height[right]:
                left_max = max(left_max, height[left])
                ans += left_max - height[left]
                left += 1
            else:
                right_max = max(right_max, height[right])
                ans += right_max - height[right]
                right -= 1
        return ans
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

</details>

<details>
<summary>

#### Additional materials

</summary>

- [Two Pointers Â· USACO Guide](https://usaco.guide/silver/two-pointers?lang=cpp)
- [Solved all two pointers problems in 100 days. - LeetCode Discuss](https://leetcode.com/discuss/study-guide/1688903/Solved-all-two-pointers-problems-in-100-days)
- [How to Solve Sliding Window Problems](https://medium.com/outco/how-to-solve-sliding-window-problems-28d67601a66)
- [Solved all two pointers problems in 100 days. - LeetCode Discuss](https://leetcode.com/discuss/study-guide/1688903/Solved-all-two-pointers-problems-in-100-days)
- [Algorithm Templates: Two Pointers](https://www.pluralsight.com/resources/blog/guides/algorithm-templates-two-pointers-part-1)

</details>

## Sliding window

<AlgorithmSummary
  tc={{ latex: "$$O(n)$$" }}
  sc={{
    latex: (
      <ul>
        <li>\(O(1)\) if only 2 pointers tracked</li>
        <li>\(O(w)\) if window elements tracked</li>
      </ul>
    ),
  }}
/>

Maintain a dynamic window that slides through the array or string, adjusting its boundaries as needed to track relevant elements or characters.

#### Use cases

- **Contiguous** data: array, linked list, string, or stream
- Processing subsets of elements: The problem requires repeated computations on a **contiguous subset** of data elements (a subarray or a substring) of **fixed** or **variable** length
- Find longest, shortest or target values of a sequence

#### Types

- Fixed window size
  - <ProblemBadge difficulty="Medium" /> [2461. Maximum Sum of Distinct Subarrays
    With Length K](https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/description/)
- Variable window size
  - <ProblemBadge difficulty="Medium" /> [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/description/)

<details>
<summary>

#### Problem examples

</summary>

<br />

<Problem 
  title="2461. Maximum Sum of Distinct Subarrays With Length K" 
  link="https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/description/"
  difficulty="Medium"
    example={{
    input: "`nums` = [1,5,4,2,9,9,9], k = 3",
    output: "15",
    explanation: "The subarray of length 3 with max sum of 15 is [4,2,9]"
}}
>
You are given an integer array `nums` and an integer `k`. Find the maximum subarray sum of all the subarrays of nums that meet the following conditions:

- The length of the subarray is `k`
- All the elements of the subarray are **distinct**.

Return the **maximum subarray sum** of all the subarrays that meet the conditions.
If no subarray meets the conditions, return **0**.

</Problem>

```py filename="2461. Maximum Sum of Distinct Subarrays With Length K"
class Solution:
    def maximum_subarray_sum(self, nums, k):
        res = cur_sum = 0
        last_seen_to_idx = {}
        last_seen = -1

        for i, num in enumerate(nums):
            cur_sum += num
            if i >= k:
                cur_sum -= nums[i - k]
            last_seen = max(last_seen, last_seen_to_idx.get(num, -1))
            if i - last_seen >= k:
                res = max(res, cur_sum)
            last_seen_to_idx[num] = i

        return res
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(n)\)" />

---

<Problem
  title="209. Minimum Size Subarray Sum"
  link="https://leetcode.com/problems/minimum-size-subarray-sum/description"
  difficulty="Medium"
  example={{
    input: "target = 7, nums = [2,3,1,2,4,3]",
    output: "2",
    explanation:
      "The subarray [4,3] has the minimal length under the problem constraint.",
  }}
>
  Given an array of positive integers `nums` and a positive integer `target`,
  return the minimal length of a subarray whose sum is greater than or equal to
  `target`. If there is no such subarray, return `0` instead.
</Problem>

```py filename="209. Minimum Size Subarray Sum"
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        left = 0
        right = 0
        sumOfCurrentWindow = 0
        res = float('inf')

        for right in range(0, len(nums)):
            sumOfCurrentWindow += nums[right]

            while sumOfCurrentWindow >= target:
                res = min(res, right - left + 1)
                sumOfCurrentWindow -= nums[left]
                left += 1

        return res if res != float('inf') else 0
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

</details>

## Greedy

### Sometimes we can do the things retrospectively:

- [1642. Furthest Building You Can Reach](https://leetcode.com/problems/furthest-building-you-can-reach/description/) - Setting all the ladders and than retrospectively substitute them with bricks:

```py
class Solution:
    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:
        pq = []
        for i in range(len(heights) - 1):
            delta = heights[i + 1] - heights[i]
            if delta <= 0:
                continue
            if ladders:
                ladders -= 1
                heappush(pq, delta)
            elif bricks >= delta or (pq and bricks >= pq[0]):
                top = heappushpop(pq, delta)
                bricks -= top
            else:
                return i
        return len(heights) - 1
```

- [134. Gas Station](https://leetcode.com/problems/gas-station/) - On each iteration: Check the furthest you can go with current gas. Remember where max gas was. If current gas is empty, retrospectively load tank with gas from max station.

```py
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        cur_gas = 0
        total_gas = 0
        ans = 0
        for i in range(len(gas)):
            cur_gas += gas[i] - cost[i]
            total_gas += gas[i] - cost[i]
            if cur_gas < 0:
                cur_gas = 0
                ans = i + 1
        if total_gas < 0:
            return -1
        return ans
```

## Dijkstra's shortest path

#### Description

1. Set `distances` from initial node to each node: `0` to initial, `Infinity` to others
2. Init `Priority queue` `pq` to store potential min nodes
3. While `pq`:
   1. Pop nim node from `pq`
   2. Set all adjacent nodes `new distance = cur distance (it's minimal) + edge distances`. Set only if it's less than current adjacent node distance
   3. Add all adjacent nodes to `pq` with updated distances

#### Finding path

Backtrack from end node to start node:

1. On each iteration pick adjacent nodes to current
2. Set current to minimal
3. Add new node to result array
4. Return reversed array

Instead of backtracking, we can set `parent` nodes during main Dijkstra's algorithm. When it's finished:

1. Pick end node
2. Iteratively go to parent and remember current node (push it to result array)
3. return reversed array

## Dynamic Programming

Resources:

- [USACO Guide](https://usaco.guide/gold/intro-dp?lang=py)
- [Miro board with examples](https://miro.com/app/board/uXjVKsh2Zg4=/)

**Dynamic programming** is a computer programming technique where an algorithmic problem is first broken down into sub-problems, the results are saved, and then the sub-problems are optimized to find the overall solution.

#### Why use DP?

- The problem can be divided by subproblems
- The subproblems are overlapping

#### 3 main components:

1. **State** - stores answer for i-th subproblem
2. **Transition between states** - how to get new solution based on previously calculated
3. **Base case**

#### Approaches

- **Top-Down** - try to solve main problem first, and to solve it solve subproblems recursively up to base case
- **Bottom-Up** - solve subproblems starting from the next one to base case and finishing on main problem

---

- **Push DP** - update future states based on the current state
- **Pull DP** - calculate the current state based on past states

#### Top-Down vs Bottom-Up

**Top-Down**

- Benefits: Easier to implement because of recursion
- Drawbacks: Could not be appliciable because of call stack overflow

**Bottom-Up**

- Benefits: No recursion. Sometimes is better in space than Top-Down
- Drawbacks: Harder to implement

#### Hints on using DP

- Think of Base case
- First try recursive Top-Bottom
- Then if Top-Bottom doesn't fit (because of recursive stack or to optimise space, or whatsoever) then try Bottom-Up

## Traversals

1. **DFS** (Depth First Search) - search in depth

- **Preorder** - Used to clone tree
- **Inorder** - Used to travense tree in BFS order (when traversing over BST, print nodes in sorted order)
- **Postorder** - Used to delete tree

2. **BFS** (Breadth First Search) - search neighbors first
1. **DLS** (Depth Limited Search) - DFS but with limited depth
1. **IDDFS** (Iterative Deepening Depth First Search) - DLS with increasing depth limit (1, 2, 3, ...) until target is found

## Matrix

[Miro ðŸ”—](https://miro.com/app/board/uXjVLeqOC3Q=/?share_link_id=441000358084)

**Problems with matrices**

1. Traverse in some order - [Spiral matrix](https://leetcode.com/problems/spiral-matrix-iv/description/)
2. Transform matrix - [Rotate image (matrix rotation)](https://leetcode.com/problems/rotate-image/description/)
3. Traverse on matrix as Graph (DFS, BFS, others) - [The Maze](https://leetcode.com/problems/the-maze/description/)
4. DP on matrix - [Maximal Square](https://leetcode.com/problems/maximal-square/description/)

## Bonus

### Greatest Common Divisor (GCD)

**Euclidean method** [ðŸ”—](https://en.wikipedia.org/wiki/Euclidean_algorithm)

This method is based on the principle:

> GCD doesn't change if we replace bigger number by difference of 2 numbers: `gcd(a, b) = gcd(a - b, b)`
> To make finding more efficient, `a - b` is changed to `a % b`:

<details>
<summary>

#### Problem examples

</summary>

<Problem
  title="2807. Insert Greatest Common Divisors in Linked List"
  link="https://leetcode.com/problems/insert-greatest-common-divisors-in-linked-list/description"
  difficulty="Medium"
>
Given the head of a linked list head, in which each node contains an integer value.

Between every pair of adjacent nodes, insert a new node with a value equal to the greatest common divisor of them.

Return the linked list after insertion.

The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.

</Problem>

<Image
  src="/algorithms-cheatsheet/2807.png"
  width="718"
  height="404"
  alt="Insert Greatest Common Divisors in Linked List example"
  priority={true}
/>

<br />

```py filename="2807. Insert Greatest Common Divisors in Linked List"
class Solution:
    def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def get_gcd(a, b):
            while b != 0:
                a, b = b, a % b
            return a
        cur = head
        while cur.next:
            gcd = get_gcd(cur.val, cur.next.val)
            cur.next = ListNode(gcd, cur.next)
            cur = cur.next.next
        return head
```

<ProblemComplexity tc="\(O(n \cdot \log(\min(a,b)))\)" sc="\(O(1)\)" />

</details>

### Prefix sums

#### Use cases

- Find a number of continuous subarrays / submatrices / tree paths that sum to target paths that sum to target
  - <ProblemBadge difficulty="Medium" /> [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/description/)
