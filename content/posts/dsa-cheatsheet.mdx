---
title: Algorithms and Data Structures Cheatsheet
description: A quick reference guide to some of the most commonly used algorithms in DSA
date: "2024-10-28"
---

<details>
<summary>

### Table of contents

</summary>

- [Time and Space Complexity. Big O Notation](#time-and-space-complexity-big-o-notation)
- [Two pointers](#two-pointers)
- [Sliding window](#sliding-window)
- [Intervals](#intervals)
- [Linked List](#linked-list)
- [Heap: Introduction](#heap-introduction)
- [Heap: Two heaps](#heap-two-heaps)
- [Heap: K-Way Merge](#heap-k-way-merge)
- [Heap: Top K Elements](#heap-top-k-elements)
- [Binary search](#binary-search)
- [Dynamic Programming](#dynamic-programming)

</details>

## Time and Space Complexity. Big O Notation

#### Time Complexity

Indicated **how fast** algorithm computing time grows when input size grows.

When solving problems, we can compare algorithm **Time Complexity** to input size and validate if given algorithm fits to input size.

**Example**
$\newcommand\computeTime{0.25 \times 10^{-9}\frac{seconds}{operation}}$

- $O(n!)$ - Time Complexity
- $4 \text{ GHz}$ - Processor single-core speed

Actual time taken

- How much time it takes for 1 operation computed on $4 \text{ GHz}$ single-core processor $\rightarrow$ $4 \text{ GHz} = 4 \times 10^9 \frac{operations}{second} $ $\rightarrow$ $ \computeTime$
- If maximum `n = 8` â†’ $8! = 40320$ $\rightarrow 40320 \times \computeTime$ $= 1.008Ã—10^{âˆ’5}$ seconds. So, computer will be able to compute it in reasonable time.
- If maximum `n = 100` â†’ $100! = $  number with 158 digits $\rightarrow 100! \times \computeTime$ $\approx$ $3 \times 10^{150}$ **years**. This is $\approx 2.14 \times 10^{140}$ times longer than our universe ğŸª exists!

#### Big O Notation

Analyzes asymptotic - answers for fast function grows

Associates problem size `n` with processing time to solve problem `t`

#### Best, Worst, and Average Cases

- **Best**: Function performs minimal operations required to solve problem on input of `n` elements
- **Worst**: Maximum amount of steps required to solve problem on input of `n` elements
- **Average** Average amount of steps required to solve problem on input of `n` elements

> In real-time computing, the **worst-case** execution time is often of particular concern since it is important to know how much time might be needed in the worst case to **guarantee** that the algorithm will always finish on time.

<div align="right">
  [Wikipedia](https://en.wikipedia.org/wiki/Best,_worst_and_average_case)
</div>

#### Example - [Bogosort (Permutation sort)](https://en.wikipedia.org/wiki/Bogosort)

Bogosort creates permutation of input array and checks if it's sorted.

- **Best**: $O_{best}(n)$ - array initially sorted, so it's needed **n** operations to check if each element on right place
- **Worst**: $O_{worst}(\infty)$ - since bogosort creates random permutation each time, in worst case it will never produce sorted permutation
- **Average** $O_{avg}(n \times n!)$ - amount of permutations is $n!$

#### Order of Magnitude

A description of a function in terms of big $ O $ notation typically provides only an upper bound on the growth rate of the function.

To calculate Order of Magnitude:

- **Discard constants**:

  - $ 3n^2 + 5 \to n^2 $

- **Pick only the most significant function**:
  - $ n^2 + 2n + 1 \to n^2 $

#### Typical Operations with Big O Notation

- **Adding** two functions or complexities
  - $ O(n) + O(m) \to O(n + m)$ $\text{or}\;O(\max(n, m)) $
- **Multiplying** two functions or complexities
  - $ O(n) \times O(m) \to O(n \times m) $

#### Growth rate comparison

<Image
  src="/algorithms-cheatsheet/big-o-growth-rate.svg"
  width="718"
  height="404"
  alt="Trapping Rain Water example"
/>

<details>
<summary>

#### Additional materials

</summary>

- [Big-O Cheat Sheet - Algorithm Complexity Analysis](https://www.bigocheatsheet.com/)
- [Competitive Programmer's Handbook - Time Complexity](https://usaco.guide/CPH.pdf#page=30)

</details>

#### Space Complexity

Space complexity measures the memory required by an algorithm as a function of the input size

In Big $ O $ notation, common space complexities include:

- $ O(1) $ for constant space
- $ O(n) $ for linear space, and
- $ O(n^2) $ for quadratic space.

Optimizing Space complexity can lead to more efficient algorithms, especially in **large-scale** data processing.

## Two pointers

<AlgorithmSummary tc={{ latex: "$$O(n)$$" }} sc={{ latex: "$$O(1)$$" }} />

Iterating two pointers across an array to search for a pair of indices satisfying some condition in linear time.

#### Types

- Opposite directional

  - <ProblemBadge difficulty="Medium" /> [167. Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/)
  - <ProblemBadge difficulty="Hard" /> [42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/description/)

- Same directional

  - <ProblemBadge difficulty="Easy" /> [26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)

- Fast and slow pointers
  - <ProblemBadge difficulty="Easy" /> [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/description/)
  - <ProblemBadge difficulty="Easy" /> [876. Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/description/)

#### When to use

- Sequential data structure (arrays, linked lists)
- Process pairs
- Remove duplicates from a sorted data
- Detect cycle in array
- Find a pair, triplet, or a subarray that satisfies a specific condition
- Reversing, partitioning, swapping, or rearranging
- String manipulation
- Array partitioning
- Etc. like Two sum or container with water variations

<details>
<summary>

#### Problem examples

</summary>

<br />

<Problem
  title="167. Two Sum II - Input Array Is Sorted"
  link="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description"
  difficulty="Medium"
>

Given a 1-indexed array of integers `numbers` that is already sorted in non-decreasing order, find two numbers such that they add up to a specific `target` number.

</Problem>

```py filename="167. Two Sum II - Input Array Is Sorted"
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        low = 0
        high = len(numbers) - 1
        while low < high:
            sum = numbers[low] + numbers[high]

            if sum == target:
                return [low + 1, high + 1]
            elif sum < target:
                low += 1
            else:
                high -= 1
        return [-1, -1]
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

---

<Problem
  title="876. Middle of the Linked List"
  link="https://leetcode.com/problems/middle-of-the-linked-list/description"
  difficulty="Easy"
>

Given the `head` of a singly linked list, return the middle node of the linked list.

If there are two middle nodes, return the second middle node.

</Problem>

```py filename="876. Middle of the Linked List"
class Solution:
    def middleNode(self, head):
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

---

<Problem
  title="42. Trapping Rain Water"
  link="https://leetcode.com/problems/trapping-rain-water/description"
  difficulty="Hard"
>

Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.

</Problem>

<Image
  src="/algorithms-cheatsheet/rain-water.png"
  width="718"
  height="404"
  alt="Trapping Rain Water example"
/>

```py filename="42. Trapping Rain Water"
class Solution:
    def trap(self, height: List[int]) -> int:
        left, right = 0, len(height) - 1
        ans = 0
        left_max, right_max = 0, 0
        while left < right:
            if height[left] < height[right]:
                left_max = max(left_max, height[left])
                ans += left_max - height[left]
                left += 1
            else:
                right_max = max(right_max, height[right])
                ans += right_max - height[right]
                right -= 1
        return ans
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

</details>

<details>
<summary>

#### Additional materials

</summary>

- [Two Pointers Â· USACO Guide](https://usaco.guide/silver/two-pointers?lang=cpp)
- [Solved all two pointers problems in 100 days. - LeetCode Discuss](https://leetcode.com/discuss/study-guide/1688903/Solved-all-two-pointers-problems-in-100-days)
- [How to Solve Sliding Window Problems](https://medium.com/outco/how-to-solve-sliding-window-problems-28d67601a66)
- [Solved all two pointers problems in 100 days. - LeetCode Discuss](https://leetcode.com/discuss/study-guide/1688903/Solved-all-two-pointers-problems-in-100-days)
- [Algorithm Templates: Two Pointers](https://www.pluralsight.com/resources/blog/guides/algorithm-templates-two-pointers-part-1)
- [Two-Pointer Algorithm Explained: Practical Applications and Examples](<https://medium.com/@t.hasan.prince/two-pointer-algorithm-explained-practical-applications-and-examples-fc2c8bd137ca#:~:text=Array%20(%20path%20):%20This%20array,than%20targetSum%20%2C%20Alice%20moves%20forward.>)

</details>

## Sliding window

<AlgorithmSummary
  tc={{ latex: "$$O(n)$$" }}
  sc={{
    latex: (
      <ul>
        <li>\(O(1) - if\;only\;\)\(2\;pointers\;tracked\)</li>
        <li>\(O(w) - if\;window\;\)\(elements\;tracked\)</li>
      </ul>
    ),
  }}
/>

Maintain a **dynamic window** that slides through the array or string, adjusting its boundaries as needed to track relevant elements or characters.

Convert **multiple nested loops into single loop**, reducing the time complexity from $O(nÂ²)$ or $O(nÂ³)$ to $O(n)$.

#### Types

- **Fixed window size**
  - <ProblemBadge difficulty="Medium" /> [2461. Maximum Sum of Distinct Subarrays
    With Length K](https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/description/)
- **Variable window size**
  - Approach:
    - **Initialize window indices**: Start with `start` and `end` pointers at the first element.
    - **Expand the window**: Increment the `end` pointer to expand the window if conditions are met.
    - **Process the window**: Perform required operations when the window meets criteria.
    - **Adjust the window size**: Move the `start` pointer to adjust size and meet desired criteria.
  - <ProblemBadge difficulty="Medium" /> [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/description/)
- **Growing window**:
  - <ProblemBadge difficulty="Medium" /> [3. Longest Substring Without Repeating
    Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/)
  - <ProblemBadge difficulty="Medium" /> [904. Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/description/)
- **Shrinking window**
- **Multiple windows**: Maintaining overlapping or disjoint windows can help solve problems more efficiently.
  - <ProblemBadge difficulty="Hard" /> [992. Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/editorial/)

#### When to use

- **Contiguous** data: array, linked list, string, or stream
- Processing subsets of elements: The problem requires repeated computations on a **contiguous subset** of data elements (a subarray or a substring) of **fixed** or **variable** length
- Find longest, shortest or target values of a sequence

#### Problem patterns

1. **Running Average**: Efficiently calculate the average of a fixed-size window in a data stream.
1. **Formulating Adjacent Pairs**: Process adjacent pairs in an ordered structure for easy access and operation.
1. **Target Value Identification**: Adjust window size to search efficiently for specific values or subarrays.
1. **Longest/Shortest/Most Optimal Sequence**: Identify the desired sequence in a collection by sliding a window through it.

<details>
<summary>

#### Real World usage

</summary>

- **String Manipulation**:
  - Substring Search: Finding the longest substring without repeating characters.
  - Pattern Matching: Searching for a pattern within a larger string efficiently.
  - Text Processing: Analyzing text data for specific patterns or occurrences.
- **Array Manipulation**:
  - Subarray Problems: Finding the maximum sum, product, or average of a subarray of fixed or variable size.
  - Data Processing: Analyzing time series data, such as stock prices or sensor readings, to identify trends or anomalies.
- **Window-based Algorithms**:

  - Sliding Window Aggregations: Calculating moving averages, rolling sums, or other window-based aggregations in data analysis.
  - Stream Processing: Handling data streams by maintaining a sliding window over the stream to perform computations in real-time.

- **Data Compression**:
  - Sliding window compression algorithms, like [LZ77](https://en.wikipedia.org/wiki/LZ77_and_LZ78) and its variants, use a window to find repeated patterns in the input data and replace them with references to previous occurrences.
- **Image Processing**:
  - In image processing, a sliding window can be employed for tasks such as feature extraction, object detection, or image segmentation.
- **Signal Processing**:
  - Time-series data can be analyzed using a sliding window to capture local patterns, trends, or anomalies.
- **Network Traffic Analysis**:
  - Anomaly Detection: Identifying anomalous patterns in network traffic by analyzing data within sliding windows.
  - Performance Monitoring: Monitoring network performance metrics, such as latency or throughput, over time using sliding windows.
- **Optimization Problems**:
  - Resource Allocation: Optimizing resource allocation or scheduling decisions based on dynamic window-based constraints.
- **Natural Language Processing (NLP)**:
  - Text Classification: Analyzing text documents and classifying them into categories based on sliding window features.
  - Named Entity Recognition: Identifying entities such as names, locations, or organizations within text using sliding window-based algorithms.

</details>

<details>
<summary>

#### Problem examples

</summary>

<br />

<Problem 
  title="904. Fruit Into Baskets" 
  link="https://leetcode.com/problems/fruit-into-baskets/description/"
  difficulty="Medium"
  example={{
    input: "fruits = [0,1,2,2]",
    output: "3",
    explanation: "We can pick from trees [1,2,2]. If we had started at the first tree, we would only pick from trees [0,1]."
}}
>
You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array `fruits` where `fruits[i]` is the type of fruit the ith tree produces.

You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:

- You only have **two** baskets, and each basket can only hold a **single type** of fruit. There is **no limit** on the amount of fruit each basket can hold.
- **Starting from any tree** of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked `fruits` **must** fit in one of your baskets.
- Once you reach a tree with fruit that cannot fit in your baskets, you must **stop**.
- Given the integer array `fruits`, return the **maximum number** of `fruits` you can pick.

</Problem>

<Image
  src="/algorithms-cheatsheet/904.png"
  width="718"
  height="404"
  alt="Fruit Into Baskets Example"
/>

Let's compare **Brute Force** approach with **Sliding window**.

In second approach, we **converted two nested loops into a single loop** thus improving Time Complexity from $O(n^2)$ to $O(n)$:

```py filename="904. Fruit Into Baskets. Brute Force approach"
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        max_picked = 0

        for left in range(len(fruits)):
            basket = set()
            right = left

            while right < len(fruits):
                if fruits[right] not in basket and len(basket) == 2:
                    break
                basket.add(fruits[right])
                right += 1

            max_picked = max(max_picked, right - left)
        return max_picked
```

<ProblemComplexity tc="\(O(n^2)\)" sc="\(O(1)\)" />

---

```py filename="904. Fruit Into Baskets. Sliding window approach"
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        basket = {}
        max_picked = 0
        left = 0

        for right in range(len(fruits)):
            basket[fruits[right]] = basket.get(fruits[right], 0) + 1

            while len(basket) > 2:
                basket[fruits[left]] -= 1
                if basket[fruits[left]] == 0:
                    del basket[fruits[left]]
                left += 1

            max_picked = max(max_picked, right - left + 1)
        return max_picked
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

---

<Problem 
  title="2461. Maximum Sum of Distinct Subarrays With Length K" 
  link="https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/description/"
  difficulty="Medium"
    example={{
    input: "nums = [1,5,4,2,9,9,9], k = 3",
    output: "15",
    explanation: "The subarray of length 3 with max sum of 15 is [4,2,9]"
}}
>
You are given an integer array `nums` and an integer `k`. Find the maximum subarray sum of all the subarrays of nums that meet the following conditions:

- The length of the subarray is `k`
- All the elements of the subarray are **distinct**.

Return the **maximum subarray sum** of all the subarrays that meet the conditions.
If no subarray meets the conditions, return **0**.

</Problem>

```py filename="2461. Maximum Sum of Distinct Subarrays With Length K"
class Solution:
    def maximum_subarray_sum(self, nums, k):
        res = cur_sum = 0
        last_seen_to_idx = {}
        last_seen = -1

        for i, num in enumerate(nums):
            cur_sum += num
            if i >= k:
                cur_sum -= nums[i - k]
            last_seen = max(last_seen, last_seen_to_idx.get(num, -1))
            if i - last_seen >= k:
                res = max(res, cur_sum)
            last_seen_to_idx[num] = i

        return res
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(n)\)" />

---

<Problem
  title="209. Minimum Size Subarray Sum"
  link="https://leetcode.com/problems/minimum-size-subarray-sum/description"
  difficulty="Medium"
  example={{
    input: "target = 7, nums = [2,3,1,2,4,3]",
    output: "2",
    explanation:
      "The subarray [4,3] has the minimal length under the problem constraint.",
  }}
>
  Given an array of positive integers `nums` and a positive integer `target`,
  return the minimal length of a subarray whose sum is greater than or equal to
  `target`. If there is no such subarray, return `0` instead.
</Problem>

```py filename="209. Minimum Size Subarray Sum"
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        left = 0
        right = 0
        sumOfCurrentWindow = 0
        res = float('inf')

        for right in range(0, len(nums)):
            sumOfCurrentWindow += nums[right]

            while sumOfCurrentWindow >= target:
                res = min(res, right - left + 1)
                sumOfCurrentWindow -= nums[left]
                left += 1

        return res if res != float('inf') else 0
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

---

<Problem
  title="1456. Maximum Number of Vowels in a Substring of Given Length"
  link="https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/"
  difficulty="Medium"
  example={{
    input: "s = \"abciiidef\", k = 3",
    output: "3",
    explanation:
      "The substring \"iii\" contains 3 vowel letters.",
  }}
>

Given a string `s` and an integer `k`, return the maximum number of vowel letters in any substring of s with length `k`.

</Problem>

```py filename="1456. Maximum Number of Vowels in a Substring of Given Length"
class Solution:
    def maxVowels(self, s: str, k: int) -> int:
        vowels = set("aeiou")
        count = 0
        for i in range(k):
            count += int(s[i] in vowels)
        answer = count
        for i in range(k, len(s)):
            count += int(s[i] in vowels)
            count -= int(s[i - k] in vowels)
            answer = max(answer, count)

        return answer
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

</details>

<details>
<summary>

#### Additional materials

</summary>

- [Sliding Window - USACO Guide](https://usaco.guide/gold/sliding-window?lang=py)
- [Mastering Sliding Window Techniques | by Ankit Singh | Medium](https://medium.com/@rishu__2701/mastering-sliding-window-techniques-48f819194fd7)
- [Sliding Window Technique: A Comprehensive Guide - LeetCode Discuss](https://leetcode.com/discuss/interview-question/3722472/mastering-sliding-window-technique-a-comprehensive-guide)

</details>

## Intervals

<AlgorithmSummary tc={{ latex: "$$O(n)$$" }} sc={{ latex: "$$O(1)$$" }} />

Typical interval problem deals with **array of overlapping intervals** e.g. `[[1, 3], [3, 5]]`

Common tasks with intervals:

- Merging intersecting intervals
  - <ProblemBadge difficulty="Medium" /> [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/description/)
- Inserting new intervals into existing sets
  - <ProblemBadge difficulty="Medium" /> [57. Insert Interval](https://leetcode.com/problems/insert-interval/description/)
- Schedule tasks
  - <ProblemBadge difficulty="Medium" /> [621. Task Scheduler](https://leetcode.com/problems/task-scheduler/description/)
- Arrange meeting rooms
  - <ProblemBadge difficulty="Medium" /> [253. Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/description/)
- Determining the minimum number of intervals needed to cover a given range

#### Corner cases

- No intervals
- Single interval
- Two intervals
- Non-overlapping intervals
- An interval totally consumed within another interval
- Duplicate intervals (exactly the same start and end)
- Intervals which start right where another interval ends - `[[1, 2], [2, 3]]`

#### When to use

- Given intervals
- Find union / intersection / gaps

<details>
<summary>

#### Real World usage

</summary>

- **Event scheduling**
- **Resource allocation**: Schedule tasks for the OS based on task priority and the free slots in the machineâ€™s processing schedule
- **Time slot consolidation**

</details>
<details>
<summary>
#### Problem examples

</summary>

<br />

<Problem
  title="56. Merge Intervals"
  link="https://leetcode.com/problems/merge-intervals/description/"
  difficulty="Medium"
  example={{
    input: "intervals = [[1,3], [2,6], [8,10], [15,18]]",
    output: "[[1,6], [8,10], [15,18]]",
    explanation: "Since intervals [1,3] and [2,6] overlap, merge them into [1,6].",
  }}
>

Given an array of intervals where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.

</Problem>

```py filename="56. Merge Intervals"
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key=lambda x: x[0])
        merged = []

        for interval in intervals:
            if not merged or merged[-1][1] < interval[0]:
                merged.append(interval)
            else:
                merged[-1][1] = max(merged[-1][1], interval[1])

        return merged
```

<ProblemComplexity
  tc="\(O(n*log(n))\)"
  sc="\(O(n)\) or \(O(log(n))\) depending on sorting algorithm"
/>

---

<Problem
  title="57. Insert Interval"
  link="https://leetcode.com/problems/insert-interval/description/"
  difficulty="Medium"
    example={{
    input: "intervals = [[1,2], [3,5], [6,7], [8,10], [12,16]], newInterval = [4,8]",
    output: "[[1,2], [3,10], [12,16]]",
    explanation: "Because the new interval [4,8] overlaps with [3,5], [6,7], [8,10].",
  }}
>

You are given an array of non-overlapping intervals `intervals` where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> represent the start and the end of the <code>i<sup>th</sup></code> interval and `intervals` is sorted in ascending order by <code>start<sub>i</sub></code>. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval.

Insert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by <code>start<sub>i</sub></code> and `intervals` still does not have any overlapping intervals (**merge** overlapping intervals if necessary).

Return intervals after the insertion.

Note that you don't need to modify intervals in-place. You can make a new array and return it.

</Problem>

Problem can be dropped down into 2 subproblems:

1. Find correct place for `newInterval`
   - Since `intervals` is sorted, we can utilize binary search.
2. Merge it with any overlapping intervals
   - Linear iteration over intervals

```py filename="57. Insert Interval"
class Solution:
    def insert(
        self, intervals: List[List[int]], newInterval: List[int]
    ) -> List[List[int]]:
        # If the intervals vector is empty, return a vector containing the newInterval
        if not intervals:
            return [newInterval]

        n = len(intervals)
        target = newInterval[0]
        left, right = 0, n - 1

        # Binary search to find the position to insert newInterval
        while left <= right:
            mid = (left + right) // 2
            if intervals[mid][0] < target:
                left = mid + 1
            else:
                right = mid - 1

        # Insert newInterval at the found position
        intervals.insert(left, newInterval)

        # Merge overlapping intervals
        res = []
        for interval in intervals:
            # If res is empty or there is no overlap, add the interval to the result
            if not res or res[-1][1] < interval[0]:
                res.append(interval)
            # If there is an overlap, merge the intervals by updating the end of the last interval in res
            else:
                res[-1][1] = max(res[-1][1], interval[1])
        return res
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(n)\)" />

---

<Problem
  title="621. Task Scheduler"
  link="https://leetcode.com/problems/task-scheduler/description/"
  difficulty="Medium"
  example={{
    input: `tasks = ["A","A","A","B","B","B"], n = 2`,
    output: "8",
    explanation: <span>A possible sequence is: <code>A â†’ B â†’ idle â†’ A â†’ B â†’ idle â†’ A â†’ B</code>.<br/> After completing task <i>A</i>, you must wait two intervals before doing <i>A</i> again. The same applies to task <i>B</i>. In the 3 interval, neither <i>A</i> nor <i>B</i> can be done, so you <i>idle</i>. By the 4 interval, you can do <i>A</i> again as 2 intervals have passed.</span>
}}

>

You are given an array of CPU `tasks`, each labeled with a letter from A to Z, and a number `n`. Each CPU interval can be idle or allow the completion of one task. Tasks can be completed in any order, but there's a **constraint**:
There has to be a gap of at least `n` intervals between two tasks with the same label.

Return the **minimum number** of CPU intervals required to complete all `tasks`.

</Problem>

```py filename="621. Task Scheduler"
class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        counter = Counter(tasks)
        max_heap = [-val for val in counter.values()]
        heapify(max_heap)
        res = 0
        while max_heap:
            cycle = n + 1
            tasks = []
            while cycle and max_heap:
                task = -heappop(max_heap)
                cycle -= 1
                if task > 1:
                    tasks.append(-(task - 1))
            while tasks:
                heappush(max_heap, tasks.pop())
            res += n + 1 if max_heap else n - cycle + 1

        return res
```

<ProblemComplexity
  tc="\(O(n*log(26)) \rightarrow O(n)\)"
  sc="\(O(26) \rightarrow O(1)\)"
/>

---

<Problem
  title="253. Meeting Rooms II"
  link="https://leetcode.com/problems/meeting-rooms-ii/description/"
  difficulty="Medium"
>

Given an array of meeting time intervals `intervals` where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, return the **minimum number of conference rooms** required.

</Problem>

```py filename="253. Meeting Rooms II"
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        intervals.sort()
        end_times = []
        for start, end in intervals:
            if not end_times or end_times[0] > start:
                heapq.heappush(end_times, end)
            else:
                heapq.heapreplace(end_times, end)

        return len(end_times)
```

<ProblemComplexity tc="\(O(n*log(n))\)" sc="\(O(n)\)" />

</details>

<details>
<summary>

#### Additional materials

</summary>

- [Interval cheatsheet for coding interviews](https://www.techinterviewhandbook.org/algorithms/interval/)
- [Merge Intervals](https://www.educative.io/courses/grokking-coding-interview/merge-intervals)

</details>

## Linked List

<AlgorithmSummary
  tc={{
    latex: (
      <ul>
        <li>\(Insert, Remove - O(1)\)</li>
        <li>\(Get\;by\;index, Search - O(n)\)</li>
      </ul>
    ),
  }}
  sc={{ latex: "$$O(1)$$" }}
/>

This section focuses on **in-place** operations with Linked Lists.

#### Properties

- Sequential data structure (like array, unlike tree)
- Slow access, but fast add / delete operations

#### Types

- Singly-linked list
- Doubly-linked list
- Circular-linked list

#### Example of Linked List

```py filename="Typical ListNode in LeetCode"
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

first_node = ListNode(1)
second_node = ListNode(2)

first_node.next = second_node
```

```py
â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”
â”‚  1  â”¼â”€â”€â”€â–ºâ”‚  2  â”¼â”€â”€â”€x
â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜
```

#### Dummy node technique

If operation is going to be performed on head or tail node, we can create `dummy` node, and point `dummy.next` to `head`. It helps not to handle edge cases for head only:

```py filename="dummy node usage example"
dummy = ListNode()
dummy.next = head

# perform operations on dummy.next
# we don't need to handle head specifically

return dummy.next
```

#### Typical operations with Linked Lists

- **List Node operations**
  - Swap nodes <ProblemBadge difficulty="Medium" /> [1721. Swapping Nodes in a Linked List](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/description/)
  - Remove node <ProblemBadge difficulty="Medium" /> [237. Delete Node in a Linked List](https://leetcode.com/problems/delete-node-in-a-linked-list/description/)
- **Whole List operations**
  - Reverse <ProblemBadge difficulty="Easy" /> [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/description/)
  - Reorder <ProblemBadge difficulty="Medium" /> [143. Reorder List](https://leetcode.com/problems/reorder-list/description/)
  - Split <ProblemBadge difficulty="Medium" /> [725. Split Linked List in Parts](https://leetcode.com/problems/split-linked-list-in-parts/description/)
  - Merge 2 or more lists <ProblemBadge difficulty="Hard" /> [23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/description/)
- **Search**
  - Find middle <ProblemBadge difficulty="Easy" /> [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/description/)
  - Find cycle <ProblemBadge difficulty="Easy" /> [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/description/)
- **Custom data structures** with Linked List under the hood
  - <ProblemBadge difficulty="Medium" /> [146. LRU Cache](https://leetcode.com/problems/lru-cache/description/)
  - <ProblemBadge difficulty="Hard" /> [460. LFU Cache](https://leetcode.com/problems/lfu-cache/description/)

#### When to use

- **Linked list restructuring**: The input data is given as a linked list, and the task is to modify its structure without modifying the data of the individual nodes.
- **In-place modification**: The modifications to the linked list must be made in place, that is, weâ€™re not allowed to use more than $O(1)$ additional space.

<details>
<summary>

#### Problem examples

</summary>

<br />

<Problem
  title="206. Reverse Linked List"
  link="https://leetcode.com/problems/reverse-linked-list/description/"
  difficulty="Easy"
>

Given the `head` of a singly linked list, reverse the list, and return the reversed list.

</Problem>

**Iterative approach**

```py filename="206. Reverse Linked List - Iterative"
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        prev = None
        curr = head
        while curr:
            next_temp = curr.next
            curr.next = prev
            prev = curr
            curr = next_temp

        return prev
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

**Recursive approach**

Note: Space complexity grows to $O(n)$ because each `head` is stored in call stack.

```py filename="206. Reverse Linked List - Recursive"
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if (not head) or (not head.next):
            return head

        p = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return p
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(n)\)" />

---

<Problem
  title="141. Linked List Cycle"
  link="https://leetcode.com/problems/linked-list-cycle/description/"
  difficulty="Easy"
>

Given `head`, the head of a linked list, determine if the linked list has a **cycle** in it.

Return `true` if there is a cycle in the linked list. Otherwise, return `false`.

```py
â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”
â”‚  1  â”¼â”€â”€â”€â–ºâ”‚  2  â”¼â”€â”€â”€â–ºâ”‚  3  â”¼â”€â”
â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜ â”‚
  â–²                           â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

</Problem>

```py filename="141. Linked List Cycle - Floyd's Cycle Finding Algorithm"
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        if head is None:
            return False
        slow = head
        fast = head.next
        while slow != fast:
            if fast is None or fast.next is None:
                return False
            slow = slow.next
            fast = fast.next.next
        return True
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

---

<Problem
  title="143. Reorder List"
  link="https://leetcode.com/problems/reorder-list/description/"
  difficulty="Medium"
>

You are given the `head` of a singly linked-list. The list can be represented as:

**L<sub>0</sub> â†’ L<sub>1</sub> â†’ â€¦ â†’ L<sub>n - 1</sub> â†’ L<sub>n</sub>**

Reorder the list to be on the following form:

**L<sub>0</sub> â†’ L<sub>n</sub> â†’ L<sub>1</sub> â†’ L<sub>n - 1</sub> â†’ L<sub>2</sub> â†’ L<sub>n - 2</sub> â†’ â€¦**

You may not modify the values in the list's nodes. Only nodes themselves may be changed.

**Visual algorithm**

```py
1. Initial list:
â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”
â”‚  1  â”¼â”€â”€â”€â–ºâ”‚  2  â”¼â”€â”€â”€â–ºâ”‚  3  â”¼â”€â”€â”€â–ºâ”‚  4  â”¼â”€â”€â”€â–ºâ”‚  5  â”¼â”€â”€â”€â–ºnull
â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜

2. Find middle (middle points to 3):
â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”
â”‚  1  â”¼â”€â”€â”€â–ºâ”‚  2  â”¼â”€â”€â”€â–ºâ”‚  3  â”¼â”€â”€â”€â–ºâ”‚  4  â”¼â”€â”€â”€â–ºâ”‚  5  â”¼â”€â”€â”€â–ºnull
â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜
                         â–²
                      middle

3. Reverse second half (4->5 becomes 5->4):
â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”
â”‚  1  â”¼â”€â”€â”€â–ºâ”‚  2  â”¼â”€â”€â”€â–ºâ”‚  3  â”¼â”€â”€â”€â–ºâ”‚  4  â—„â”€â”€â”€â”€â”‚  5  â”‚
â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜
                                             prev

4. Start merging (first=1, second=5):
â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”
â”‚  1  â”¼â”€â”  â”‚  2  â”¼â”€â”€â”€â–ºâ”‚  3  â”¼â”€â”€â”€â–ºâ”‚  4  â—„â”€â”€â”€â”€â”‚  5  â”‚
â””â”€â”€â”€â”€â”€â”˜ â”‚  â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜
        â”‚                                       â–²
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

5. Final reordered list:
â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”
â”‚  1  â”¼â”€â”€â”€â–ºâ”‚  5  â”¼â”€â”€â”€â–ºâ”‚  2  â”¼â”€â”€â”€â–ºâ”‚  4  â”¼â”€â”€â”€â–ºâ”‚  3  â”¼â”€â”€â”€â–ºnull
â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜
```

</Problem>

```py filename="143. Reorder List"
class Solution:
    def reorderList(self, head: ListNode) -> None:
        if not head:
            return

        # find the middle of linked list [Problem 876]
        # in 1->2->3->4->5->6 find 4
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        # reverse the second part of the list [Problem 206]
        # convert 1->2->3->4->5->6 into 1->2->3->4 and 6->5->4
        # reverse the second half in-place
        prev, curr = None, slow
        while curr:
            curr.next, prev, curr = prev, curr, curr.next

        # merge two sorted linked lists [Problem 21]
        # merge 1->2->3->4 and 6->5->4 into 1->6->2->5->3->4
        first, second = head, prev
        while second.next:
            first.next, first = second, first.next
            second.next, second = first, second.next
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

</details>

<details>
<summary>

#### Additional materials

</summary>

- [Become Master In Linked List - LeetCode Discuss](https://leetcode.com/discuss/study-guide/1800120/become-master-in-linked-list)
- [Whatâ€™s a Linked List, Anyway? [Part 1] | by Vaidehi Joshi | basecs | Medium](https://medium.com/basecs/whats-a-linked-list-anyway-part-1-d8b7e6508b9d)
- [Linked list cheatsheet for coding interviews](https://www.techinterviewhandbook.org/algorithms/linked-list/)

</details>

## Heap: Introduction

<AlgorithmSummary
  tc={{
    latex: (
      <ul>
        <li>\(Find\;Min / Max - O(1)\)</li>
        <li>\(Insert, Remove - O(log(n))\)</li>
        <li>\(Heapify - O(n)\)</li>
      </ul>
    ),
  }}
  sc={{ latex: "$$O(1)$$" }}
/>

Heap is a **complete binary tree** where each node is smaller than its children (for min heap). This property is called **Heap invariant**.

Heap must always comply to **Heap invariant**

#### Priority Queue vs Heap

- Priority queue
  - Abstract data structure (like stack or queue) that behaves like queue (First In, First Out)
  - Specifies behavior of data structure
  - Doesn't define internal implementation
  - Each element has **priority** - the higher propriety element comes first
- Heap
  - Implementation of Priority queue

#### Types

- **Min heap** - each parent node **smaller of equal** to its children
- **Max heap** - each parent node **bigger or equal** to its children

#### Operations on heap

- **Add node**
  1. Add new node to end of heap
  2. Swap the node with parent if it's bigger than parent
  3. At most, $O(log(n))$ swaps could be made since heap - **Complete binary tree**. In complete binary tree, height = `log(n)`
- **Remove node**
  1. Take tree root and remove it from tree
  2. Place last element to root
  3. Swap with children to achieve **Heap invariant**
  4. At most, $O(log(n))$ swaps could be made
- **Heapify**
  1. Start from last leave
  2. If node doesn't satisfy **Heap invariant**, recursively heapify subtree
  3. Move up the tree until the entire tree satisfies the **Heap invariant**
  4. The total amount of swaps is $O(n)$

#### Array representation of Heap

Heap usually represented as array:

- Node<sub>i</sub> stored in array by index `i`
- Node<sub>i</sub> left and right children could be found by index `2 * i` and `2 * i + 1`
- It's convenient to store nodes starting from index `1`

#### Example

- Max heap
- Complete binary tree with height of 2

**Tree** representation:

```py
Level             Tree

  0:                9
                  /   \
  1:             7     8
                /
  2:           5
```

**Array** representation with indices:

```py
        â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
Value   â”‚ - â”‚ 9 â”‚ 7 â”‚ 8 â”‚ 5 â”‚
        â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
Index     0   1   2   3   4
```

#### When to use

- K-th element

  - <ProblemBadge difficulty="Medium" /> [Kth Largest Element in an Array (Problem
    215)](https://leetcode.com/problems/kth-largest-element-in-an-array/)
  - <ProblemBadge difficulty="Medium" /> [Kth Smallest Element in a Sorted Matrix
    (Problem 378)](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)

- Top K elements

  - <ProblemBadge difficulty="Medium" /> [Top K Frequent Elements (Problem 347)](https://leetcode.com/problems/top-k-frequent-elements/)
  - <ProblemBadge difficulty="Medium" /> [K Closest Points to Origin (Problem 973)](https://leetcode.com/problems/k-closest-points-to-origin/)

- Heap sort

  - <ProblemBadge difficulty="Medium" /> [Sort an Array (Problem 912)](https://leetcode.com/problems/sort-an-array/)

- Sort subset of elements resulting to TC optimization from $O(n*log(n))$ to $O(n*log(k))$ where k is heap size
  - <ProblemBadge difficulty="Medium" /> [Find K Pairs with Smallest Sums (Problem
    373)](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/)
  - <ProblemBadge difficulty="Hard" /> [Merge k Sorted Lists (Problem 23)](https://leetcode.com/problems/merge-k-sorted-lists/)

<details>
<summary>

#### Problem examples

</summary>

<br />

<Problem
  title="215. Kth Largest Element in an Array"
  link="https://leetcode.com/problems/kth-largest-element-in-an-array/description/"
  difficulty="Medium"
  example={{
    input: "nums = [3,2,1,5,6,4], k = 2",
    output: "5"
  }}
>

Given an integer array `nums` and an integer `k`, return the <code>k<sub>th</sub></code> largest element in the array.

Note that it is the <code>k<sub>th</sub></code> largest element in the sorted order, not the <code>k<sub>th</sub></code> distinct element.

Can you solve it without sorting?

</Problem>

```py filename="215. Kth Largest Element in an Array"
class Solution:
    def findKthLargest(self, nums, k):
        heap = []
        for num in nums:
            heapq.heappush(heap, num)
            if len(heap) > k:
                heapq.heappop(heap)

        return heap[0]
```

<ProblemComplexity tc="\(O(n*log(k))\)" sc="\(O(k)\)" />

---

<Problem
  title="373. Find K Pairs with Smallest Sums"
  link="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description"
  difficulty="Medium"
  example={{
    input: "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
    output: "[[1,2],[1,4],[1,6]]",
    explanation: "The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]"
  }}
>

You are given two integer arrays `nums1` and `nums2` sorted in non-decreasing order and an integer `k`.

Define a pair `(u, v)` which consists of one element from the first array and one element from the second array.

Return the `k` pairs <code>(u<sub>1</sub>, v<sub>1</sub>), (u<sub>2</sub>, v<sub>2</sub>), ..., (u<sub>k</sub>, v<sub>k</sub>)</code> with the **smallest sums**.

</Problem>

```py filename="373. Find K Pairs with Smallest Sums"
class Solution:
   def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
       heap, seen, res = [(nums1[0] + nums2[0], 0, 0)], {(0, 0)}, []
       while heap and len(res) < k:
           _, i, j = heappop(heap)
           res.append([nums1[i], nums2[j]])
           for i2, j2 in [(i, j + 1), (i + 1, j)]:
               if i2 < len(nums1) and j2 < len(nums2) and (i2, j2) not in seen:
                   seen.add((i2, j2))
                   heappush(heap, (nums1[i2] + nums2[j2], i2, j2))
       return res
```

Here, $m$ is the size of `nums1` and $n$ is the size of `nums2`:

<ProblemComplexity
  tc="\(O(min(k*log(k),m*n*log(m*n)))\)"
  sc="\(O(min(k,m*n))\)"
/>

</details>

<details>
<summary>

#### Real World usage

</summary>

- **Network routing**
  - Dijkstra's algorithm uses heaps to efficiently find the shortest path between network nodes by maintaining shortest distances as priorities.
- **Process scheduling**
  - Operating systems use priority queues (heaps) to manage which process gets CPU time next based on priority levels.
- **Resource allocation**
  - In cloud computing, heaps help distribute resources (like memory or CPU) by maintaining a priority queue of requests from different applications.
- **Machine learning**
  - K-nearest neighbors algorithm uses heaps to efficiently maintain the k closest points during distance calculations and similarity searches.

</details>

<details>
<summary>

#### Additional materials

</summary>

- [Competitive Programmer's Handbook - Chapter 9: Data Structures](https://usaco.guide/CPH.pdf#page=87)
- [Tech Interview Handbook - Heap](https://www.techinterviewhandbook.org/algorithms/heap/)
- [basecs - Learning to Love Heaps](https://medium.com/basecs/learning-to-love-heaps-cef2b273a238)
- [basecs - Heapify All The Things With Heap Sort](https://medium.com/basecs/heapify-all-the-things-with-heap-sort-55ee1c93af82)
- [Yale University - Heaps](https://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#heaps)
- [LeetCode - Master Heap: Understanding 4 Patterns Where Heap Data Structure is Used](https://leetcode.com/discuss/general-discussion/1127238/master-heap-understanding-4-patterns-where-heap-data-structure-is-used)
- [LeetCode - Heap Explore Card](https://leetcode.com/explore/featured/card/heap/)

</details>

## Heap: Two heaps

<AlgorithmSummary
  tc={{ latex: "$$O(n*log(k))$$" }}
  sc={{ latex: "$$O(k)$$" }}
/>

Two heaps approach used to find out middle of moving dataset

- <ProblemBadge difficulty="Hard" /> [295. Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/description/)
- <ProblemBadge difficulty="Hard" /> [480. Sliding Window Median](https://leetcode.com/problems/sliding-window-median/description/)

It assumes having

- **Max heap** to store maximum of part of dataset
- **Min heap** to store minimum of part of dataset

#### Algorithm for finding **median** of `k`-size dataset

- **Initialization** - placing elements to heaps by $O(k*log(k))$
  1. Initialize **min heap** and **max heap**
     - **Min heap** will store elements right to the median (bigger)
     - **Max heap** will store elements left to the median (smaller)
  2. Place every item in **min heap**
  3. If **min heap** size exceeds `k // 2`
     - Pop element from **min heap** (it will be smallest one)
     - Place to **max heap**
- **Find median** - $O(1)$
  - `k` even - Average of **min heap** and **max heap** roots
  - `k` odd - **Max heap** root
- **Shift sliding window**
  - Perform steps **2-3**

#### When to use

- **Linear data**: The input data is linear but not sorted
- **Stream of data**
- **Find Max / Min**:
  - Find maximums / minimums / maximum and minimum of 2 datasets

<details>
<summary>

#### Problem examples

</summary>

<br />

<Problem
  title="502. IPO"
  link="https://leetcode.com/problems/ipo/"
 difficulty="Hard"
  example={{
    input: "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
    output: "4",
    explanation: <span>Since your initial capital is 0, you can only start the project indexed 0.
After finishing it you will obtain profit 1 and your capital becomes 1.
With capital 1, you can either start the project indexed 1 or the project indexed 2.
Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.
Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.</span>
  }}>

Suppose LeetCode will start its **IPO** soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at **most k distinct** projects before the IPO. Help LeetCode design the best way to **maximize** its total capital after finishing at **most k distinct** projects.

You are given `n` projects where the <code>i<sub>th</sub></code> project has a pure profit `profits[i]` and a minimum capital of `capital[i]` is needed to start it.

Initially, you have `w` capital. When you finish a project, you will obtain its pure profit and the profit will be added to your **total capital**.

Pick a list of at most `k` distinct projects from given projects to **maximize** your final capital, and return the final maximized capital.

The answer is guaranteed to fit in a 32-bit signed integer.

</Problem>

```py filename="502. IPO"
class Solution:
    def findMaximizedCapital(
        self, k: int, w: int, profits: List[int], capital: List[int]
    ) -> int:
        min_capitals = [(c, p) for c, p in zip(capital, profits)]
        heapq.heapify(min_capitals)
        max_profits = []
        for _ in range(k):
            while min_capitals and min_capitals[0][0] <= w:
                c, p = heapq.heappop(min_capitals)
                heapq.heappush(max_profits, -p)
            if max_profits:
                w += -heapq.heappop(max_profits)
        return w
```

<ProblemComplexity tc="\(O(n*log(n))\)" sc="\(O(n)\)" />

---

<Problem
  title="480. Sliding Window Median"
  link="https://leetcode.com/problems/sliding-window-median/description/"
  difficulty="Hard"
  example={{
    input: "nums = [1,3,-1,-3,5,3,6,7], k = 3",
    output: "[1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]",
    explanation: <pre>
<code>Window position                Median</code><br/>
<code>---------------                -----</code><br/>
<code>[1  3  -1] -3  5  3  6  7        1</code><br/>
<code> 1 [3  -1  -3] 5  3  6  7       -1</code><br/>
<code> 1  3 [-1  -3  5] 3  6  7       -1</code><br/>
<code> 1  3  -1 [-3  5  3] 6  7        3</code><br/>
<code> 1  3  -1  -3 [5  3  6] 7        5</code><br/>
<code> 1  3  -1  -3  5 [3  6  7]       6</code>
</pre>
  }}
>

The **median** is the middle value in an ordered integer list. If the size of the list is **even**, there is no middle value. So the median is the mean of the two middle values.

- For examples, if <code>arr = [2,<u>3</u>,4]</code>, the median is `3`.
- For examples, if <code>arr = [1,<u>2,3</u>,4]</code>, the median is `(2 + 3) / 2 = 2.5`.

You are given an integer array `nums` and an integer `k`. There is a **sliding window** of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.

Return the **median** array for each window in the original array. Answers within 10-5 of the actual value will be accepted.

</Problem>

```py filename="480. Sliding Window Median"
class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        def clean(h, is_min):
            while h and rm.get(h[0] if is_min else -h[0], 0):
                rm[h[0] if is_min else -h[0]] -= 1
                heapq.heappop(h)

        rm, lo, hi, res = {}, [], [], []
        for i in range(k):
            heapq.heappush(lo, -nums[i])
        for _ in range(k // 2):
            heapq.heappush(hi, -heapq.heappop(lo))

        for i in range(k, len(nums) + 1):
            res.append(-lo[0] if k % 2 else (-lo[0] + hi[0]) / 2)
            if i == len(nums):
                break

            out, in_num = nums[i - k], nums[i]
            rm[out] = rm.get(out, 0) + 1
            bal = -1 if out <= -lo[0] else 1

            if lo and in_num <= -lo[0]:
                heapq.heappush(lo, -in_num)
                bal += 1
            else:
                heapq.heappush(hi, in_num)
                bal -= 1

            if bal < 0:
                heapq.heappush(lo, -heapq.heappop(hi))
            if bal > 0:
                heapq.heappush(hi, -heapq.heappop(lo))
            clean(lo, False)
            clean(hi, True)

        return res
```

<ProblemComplexity tc="\(O(n*log(k))\)" sc="\(O(k)\)" />

</details>

<details>
<summary>

#### Additional materials

</summary>

- [Introduction to Two Heaps](https://www.educative.io/courses/grokking-coding-interview/introduction-to-two-heaps)
- [GitHub - Pattern 09: Two Heaps](https://github.com/Chanda-Abdul/Several-Coding-Patterns-for-Solving-Data-Structures-and-Algorithms-Problems-during-Interviews/blob/main/%E2%9C%85%20%F0%9F%99%83%20Pattern%2009:%20Two%20Heaps.md)

</details>

<details>
<summary>

#### Real World usage

</summary>

Two heaps approach is used when median calculation needed

- **Video platforms**: median age of the viewers
- **Gaming matchmaking**: Matching players of similar skill levels

</details>

## Heap: K-Way Merge

<AlgorithmSummary
  tc={{ latex: "$$O(n*log(k))$$" }}
  sc={{ latex: "$$O(k)$$" }}
/>

The **K-way merge** pattern combines **k** sorted data structures into a single **sorted** output.

It works by repeatedly selecting the smallest (or largest) element from among the first elements of each input list and adding it to the output list, continuing until all elements are merged in order.

K-way merge of sorted data could be achieved by:

- **Heaps**
- **Merge sort**

**Min Heap Approach**:

1. Insert first element from each list into min heap
2. Remove heap's top element, add to output
3. Replace with next element from same input list
4. Repeat until all elements merged

**Divide & Merge (merge sort)**:

1. Divide lists into 2 parts and merge each part
2. Continue dividing and merging resulting lists
3. Repeat until single sorted list remains

#### Typical problems

- <ProblemBadge difficulty="Medium" /> [378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/)
- <ProblemBadge difficulty="Medium" /> [373. Find K Pairs with Smallest Sums](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/)
- <ProblemBadge difficulty="Hard" /> [23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/description/)

#### When to use

- **Merging sorted arrays/matrix** rows/columns into a single sorted sequence
- **Finding kth smallest/largest** element across multiple sorted collections (like finding median in multiple sorted arrays)

<details>
<summary>

#### Problem examples

</summary>

<br />

<Problem
  title="378. Kth Smallest Element in a Sorted Matrix"
  link="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/"
  difficulty="Medium"
  example={{
    input: "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
    output: "13",
    explanation: "The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13"
  }}
>

Given an `n x n` matrix where each of the rows and columns is sorted in ascending order, return the <code>k<sub>th</sub></code> smallest element in the matrix.

Note that it is the <code>k<sub>th</sub></code> smallest element in the sorted order, not the <code>k<sub>th</sub></code> distinct element.

You must find a solution with a memory complexity better than $O(n^2)$.

</Problem>

```py filename="378. Kth Smallest Element in a Sorted Matrix"
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        min_heap = [(row[0], i, 0) for i, row in enumerate(matrix)]
        heapify(min_heap)

        while k:
            val, i, j = heappop(min_heap)
            k -= 1
            if j + 1 < len(matrix):
                heappush(min_heap, (matrix[i][j + 1], i, j + 1))

        return val
```

<ProblemComplexity tc="\(O(n*log(k))\)" sc="\(O(k)\)" />

---

<Problem
  title="373. Find K Pairs with Smallest Sums"
  link="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/"
  difficulty="Medium"
  example={{
    input: "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
    output: "[[1,2],[1,4],[1,6]]",
    explanation: "The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]"
  }}
>

You are given two integer arrays `nums1` and `nums2` sorted in non-decreasing order and an integer `k`.

Define a pair `(u, v)` which consists of one element from the first array and one element from the second array.

Return the `k` pairs <code>(u<sub>1</sub>, v<sub>1</sub>), (u<sub>2</sub>, v<sub>2</sub>), ..., (u<sub>k</sub>, v<sub>k</sub>)</code> with the **smallest sums**.

</Problem>

```py filename="373. Find K Pairs with Smallest Sums"
class Solution:
    def kSmallestPairs(
        self, nums1: List[int], nums2: List[int], k: int
    ) -> List[List[int]]:
        heap, seen, res = [(nums1[0] + nums2[0], 0, 0)], {(0, 0)}, []
        while heap and len(res) < k:
            _, i, j = heappop(heap)
            res.append([nums1[i], nums2[j]])
            for i2, j2 in [(i, j + 1), (i + 1, j)]:
                if i2 < len(nums1) and j2 < len(nums2) and (i2, j2) not in seen:
                    seen.add((i2, j2))
                    heappush(heap, (nums1[i2] + nums2[j2], i2, j2))
        return res
```

<ProblemComplexity tc="\(O(k*log(k))\)" sc="\(O(k)\)" />

---

<Problem
  title="23. Merge k Sorted Lists"
  link="https://leetcode.com/problems/merge-k-sorted-lists/description/"
  difficulty="Hard"
  example={{
    input: "lists = [[1,4,5],[1,3,4],[2,6]]",
    output: "[1,1,2,3,4,4,5,6]",
    explanation: <div>The linked-lists are:<br/>
  1-&gt;4-&gt;5<br/>
  1-&gt;3-&gt;4<br/>
  2-&gt;6<br/>
Merging them into one sorted list:<br/>
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
</div>
  }}
>

You are given an array of `k` linked-lists lists, each linked-list is sorted in ascending order.

Merge all the linked-lists into one sorted linked-list and return it.

</Problem>

```py filename="23. Merge k Sorted Lists"
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        head = cur = ListNode()
        heap = []
        for i, node in enumerate(lists):
            if not node:
                continue
            heappush(heap, (node.val, i))
        while heap:
            val, min_node_idx = heappop(heap)
            min_node = lists[min_node_idx]
            cur.next, cur = min_node, min_node
            if min_node.next:
                lists[min_node_idx] = min_node.next
                heappush(heap, (min_node.next.val, min_node_idx))
        return head.next
```

<ProblemComplexity tc="\(O(n*log(k))\)" sc="\(O(k)\)" />

</details>

<details>
<summary>

#### Additional materials

</summary>

- [K-way merge intro](https://docs.google.com/presentation/d/1mgOjC2VUhRjwXSkxtfz2D8d-KG7gE9KGRlsQ1glqwxs/edit?usp=sharing)
- [Wikipedia - K-way merge algorithm](https://en.wikipedia.org/wiki/K-way_merge_algorithm)
- [Baeldung - 2-Way vs K-Way Merge](https://www.baeldung.com/cs/2-way-vs-k-way-merge)
- [Emre.me - K-way Merge](https://emre.me/coding-patterns/k-way-merge/)

</details>

<details>
<summary>

#### Real World usage

</summary>

- **Patient Records Aggregation**: In healthcare, integrating data from multiple sources like lab results and physician notes into a single record is vital. The K-way merge efficiently combines these data streams, aiding in diagnosis and treatment.

- **Financial Transaction Merging**: For financial institutions, merging transactions from different sources into a single stream is essential for analysis or fraud detection. K-way merge organizes these transactions coherently, improving financial monitoring and analysis.

- **Log File Analysis**: Web services generate logs from multiple servers. Merging these into one stream for analysis requires the K-way merge, making it easier to analyze user behavior or system performance with minimal preprocessing.

</details>

## Heap: Top K Elements

<AlgorithmSummary
  tc={{ latex: "$$O(n*log(n))$$" }}
  sc={{ latex: "$$O(k)$$" }}
/>

The `top k` elements pattern is crucial for efficiently finding a specific number of elements, `k`, from a dataset.

Maintain a `heap` of size `k` while iterating through the list of elements

#### Time Complexity

Without this pattern, sorting the whole collection is $O(n*log(n))$, plus $O(k)$ to pick **top k** elements. The **top k** pattern achieves $O(n*log(k))$ by selectively tracking compared elements, using a **heap**.

#### Using Heap

A heap is ideal for managing the smallest or largest **k elements**. By using a max heap for smallest elements and a min heap for largest, we can maintain ordered elements with quick access to the smallest or largest.

#### Operating Procedure

1. Insert first k elements into the appropriate heap.
   - Min heap for largest elements.
   - Max heap for smallest elements.
2. For remaining elements:
   - In min heap (for largest elements), replace the smallest (top) with any found larger element.
   - In max heap (for smallest elements), replace the largest (top) with any found smaller element.

#### Efficiency

**Time complexity** of Top K approach using heap:

- $O(log(k))$ - insertions and removals
- $O(n*log(k))$ - processing all elements
- $O(k*log(k))$ - retrieving all `k` elements, due to reorganization after each removal.

**Time complexity comparison**

**n** - number of all items. **k** - top k elements

- Brute force - $O(n^2)$
- Sorting - $O(n * log(n))$
- Heap - $O(n * log(k))$

#### Typical problems

- <ProblemBadge difficulty="Easy" /> [703. Kth Largest Element in a Stream](https://leetcode.com/problems/kth-largest-element-in-a-stream/description/)
- <ProblemBadge difficulty="Medium" /> [767. Reorganize String](https://leetcode.com/problems/reorganize-string/description/)
- <ProblemBadge difficulty="Medium" /> [973. K Closest Points to Origin](https://leetcode.com/problems/k-closest-points-to-origin/description/)

#### When to use

- **Unsorted List Analysis**: Task involves extracting a specific subset (largest, smallest, most/least frequent) from an unsorted list, either as the final goal or an intermediate step.
- **Identifying a Specific Subset**: To identify a subset based on criteria like **top k**, <code>k<sub>th</sub> largest/smallest</code>, or **k most frequent**, indicating the top k elements pattern is a fit.

#### How to identify Top K pattern

- Top k element
- Smallest / Biggest element
- Most / Least frequent k elements
- Furthest / Nearest
- Given Unsorted data

#### Pitfalls

- Sometimes mathematical approach faster
- Sometimes other patterns faster: [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/description/)
  - [Quickselect](https://en.wikipedia.org/wiki/Quickselect) - Average Time Complexity $O(n)$
  - Heap - Average Time Complexity $O(n \times \log k)$
- If data is sorted, use **binary search** or others
- If need to find one extremum, heap is not needed

<details>
<summary>

#### Problem examples

</summary>

<br />

<Problem
  title="347. Top K Frequent Elements"
  link="https://leetcode.com/problems/top-k-frequent-elements/description/"
  difficulty="Medium"
  example={{
    input: "nums = [1,1,1,2,2,3], k = 2",
    output: "[1,2]"
  }}
>

Given an integer array `nums` and an integer `k`, return the `k` most frequent elements. You may return the answer in any order.

</Problem>

```py filename="347. Top K Frequent Elements"
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        heap = []
        for num, freq in Counter(nums).items():
            heapq.heappush(heap, (freq, num))
            if len(heap) > k:
                heapq.heappop(heap)
        return [num for freq, num in heap]
```

<ProblemComplexity tc="\(O(n*log(k))\)" sc="\(O(n + k)\)" />

---

<Problem
  title="767. Reorganize String"
  link="https://leetcode.com/problems/reorganize-string/description/"
  difficulty="Medium"
  example={{
    input: "s = \"aab\"",
    output: "\"aba\""
  }}
>

Given a string `s`, rearrange the characters of `s` so that any two adjacent characters are not the same.

Return any possible rearrangement of `s` or return `""` if not possible.

</Problem>

```py filename="767. Reorganize String"
class Solution:
    def reorganizeString(self, s: str) -> str:
        ans = []
        pq = [(-count, char) for char, count in Counter(s).items()]
        heapify(pq)

        while pq:
            count_first, char_first = heappop(pq)
            if not ans or char_first != ans[-1]:
                ans.append(char_first)
                if count_first + 1 != 0:
                    heappush(pq, (count_first + 1, char_first))
            else:
                if not pq: return ''
                count_second, char_second = heappop(pq)
                ans.append(char_second)
                if count_second + 1 != 0:
                    heappush(pq, (count_second + 1, char_second))
                heappush(pq, (count_first, char_first))

        return ''.join(ans)
```

<ProblemComplexity tc="\(O(n*log(k))\)" sc="\(O(k)\)" />

---

<Problem
  title="973. K Closest Points to Origin"
  link="https://leetcode.com/problems/k-closest-points-to-origin/description/"
  difficulty="Medium"
  example={{
    input: "points = [[1,3],[-2,2]], k = 1",
    output: "[[-2,2]]",
    explanation: `
    explanation: "The distance between (1, 3) and the origin is sqrt(10).
The distance between (-2, 2) and the origin is sqrt(8).
Since sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.
We only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].
    `
  }}
>

Given an array of points where <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> represents a point on the **X-Y** plane and an integer `k`, return the `k` closest points to the origin `(0, 0)`.

The distance between two points on the **X-Y** plane is the Euclidean distance (i.e., `âˆš(x1 - x2)2 + (y1 - y2)2)`.

You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).

<Image
  src="/algorithms-cheatsheet/973.jpg"
  width="718"
  height="404"
  alt="K Closest Points to Origin example"
/>

</Problem>

```py filename="973. K Closest Points to Origin"
class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        dist_idx_heap = []
        for i, (x, y) in enumerate(points):
            dist = sqrt(x**2 + y**2)
            heapq.heappush(dist_idx_heap, (-dist, i))
            if len(dist_idx_heap) > k:
                heapq.heappop(dist_idx_heap)
        res = []
        for dist, i in dist_idx_heap:
            res.append(points[i])
        return res
```

<ProblemComplexity tc="\(O(n*log(k))\)" sc="\(O(k)\)" />

</details>

<details>
<summary>

#### Real World usage

</summary>

- **Ride-sharing Apps**: Efficiently finding the nearest drivers for a user in apps like Uber, prioritizing the **closest n drivers** without needing to evaluate all city drivers.

- **Financial Markets**: Highlighting top brokers based on transaction volumes or success metrics, sifting through data to spotlight leaders in market activities.

- **Social Media**: Filtering top trending topics by frequency, using the top K elements pattern to analyze hashtags or keywords for content relevancy.

</details>

## Binary search

<AlgorithmSummary tc={{ latex: "$$O(\\log n)$$" }} sc={{ latex: "$$O(1)$$" }} />

**Binary search** - search algorithm in sorted array

1. It works by repeatedly **dividing the search interval in half**.
   1. If the target value is **less than** the middle element, the search continues in the left half;
   2. if greater, it continues in the right half.
2. This process is repeated until the target is found or the interval is empty.

Simple implementation

```py filename="Binary search - Iterative"
def binary_search(arr, target):
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = (left + right) // 2

        if arr[mid] == target:
            return mid  # Target found at index mid
        elif arr[mid] < target:
            left = mid + 1  # Discard the left half
        else:
            right = mid - 1  # Discard the right half

    return -1  # Target not found
```

#### Modified Binary search

- Modification of Binary search
- Applies specific conditions or transformations to address unique problems:

1. **Binary Search on a Modified Array**: Array is altered
   - <ProblemBadge difficulty="Medium" /> [33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)
     \- sorted and then rotated.
2. **Binary Search with Multiple Requirements**: Adapt the **comparison** logic to meet multiple conditions:
   - Finding a range of targets
   - Identifying the leftmost or rightmost occurrences of a value.
3. **Finding Conditions**: Identify boundary conditions
   - <ProblemBadge difficulty="Easy" /> [278. First Bad Version](https://leetcode.com/problems/first-bad-version/)
     \- locating the first instance that meets a specific criterion.

These modifications allow binary search to efficiently tackle a broader range of problems.

#### Typical problems

- Sorted array
  - Find value
  - Find range
    - <ProblemBadge difficulty="Medium" /> [34. Find First and Last Position of Element
      in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)
- Sorted array is modified (rotated)
  - <ProblemBadge difficulty="Medium" /> [33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)
  - <ProblemBadge difficulty="Medium" /> [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)
- Custom comparison (good/bad version)
  - <ProblemBadge difficulty="Easy" /> [374. Guess Number Higher or Lower](https://leetcode.com/problems/guess-number-higher-or-lower/)
  - <ProblemBadge difficulty="Easy" /> [278. First Bad Version](https://leetcode.com/problems/first-bad-version/)
  - <ProblemBadge difficulty="Medium" /> [162. Find Peak Element](https://leetcode.com/problems/find-peak-element/)
- Task can be represented by sorted data
  - <ProblemBadge difficulty="Easy" /> [69. Sqrt(x)](https://leetcode.com/problems/sqrtx/)
- Sorted Matrix
- Find insertion point

#### Comparison with other algorithms

<Image
  src="/algorithms-cheatsheet/bin-search-comparison.webp"
  width="718"
  height="404"
  alt="Comparison of Binary search with other algorithms"
/>

#### When to use

- Time Complexity constraint - $ O(\log n) $
- Linear data structure with **random access**
- Data is **sorted**
- Data structure that supports **direct addressing**: array, matrix
- There's **no linear data structure**, but data is in **sorted** order
  - <ProblemBadge difficulty="Easy" /> [278. First Bad Version](https://leetcode.com/problems/first-bad-version/)

#### Challenges using B-Search

- Identify pattern
- Find proper condition
- Not to fall into infinite loop

#### Notes

- Pre-processing might be needed
  - Sort if collection is unsorted
  - Precompute if needed
    - <ProblemBadge difficulty="Medium" /> [162. Find Peak Element](https://leetcode.com/problems/find-peak-element/)
      - Precompute cumulative sum
- Sometimes we don't want to check found element in loop

```py filename="Internal bisect.py module - bisect_left function"
    while lo < hi:
        mid = (lo + hi) // 2
        if a[mid] < x:
            lo = mid + 1
        else:
            hi = mid
    return lo
```

- Beware overflow:

```py
  mid = left + (right - left) // 2
  # vs
  mid = (right + left) // 2
```

- Sometimes we can use built-in b-search like `bisect_left` in Python
- Infinite loop:

```py
  while l <= r:
    ...
    l = mid
```

<details>
<summary>

#### Real World usage

</summary>

- **Database Searches**: Quickly locate records in sorted tables.
- **Autocomplete**: Efficiently find suggestions from sorted keyword lists.
- **Library Catalogs**: Identify book locations in sorted catalogs.
- **Version Control**: Locate specific changes in sorted commit histories (e.g., Git).
- **Game Leaderboards**: Find player scores in sorted rankings.
- **API Pagination**: Access specific data points in sorted datasets.
- **Image Processing**: Determine thresholds in pixel values for segmentation.

</details>

<details>
<summary>

#### Problem examples

</summary>

<br />

<Problem
  title="50. Pow(x, n)"
  link="https://leetcode.com/problems/powx-n/description/"
  difficulty="Medium"
  example={{
    input: "fruits = [0,1,2,2]",
    output: "3",
    explanation: "We can pick from trees [1,2,2]. If we had started at the first tree, we would only pick from trees [0,1]."
  }}
>

Implement `pow(x, n)`, which calculates `x` raised to the power `n` (i.e., <code>x<sup>n</sup></code>).

</Problem>

Brute Force

```py filename="50. Pow(x, n) - Brute Force"
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n < 0:
            return 1 / pow(x, -n)
        return x * pow(x, n - 1)
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

Binary search - Recursive

```py filename="50. Pow(x, n) - Binary search - Recursive"
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n < 0:
            return 1 / self.myPow(x, -n)
        if n == 0:
            return 1
        if n % 2:
            return x * self.myPow(x, n - 1)
        return self.myPow(x * x, n / 2)
```

<ProblemComplexity tc="\(O(\log n)\)" sc="\(O(\log n)\)" />

Binary search - Iterative

```py filename="50. Pow(x, n) - Binary search - Iterative"
class Solution:
    def binaryExp(self, x: float, n: int) -> float:
        if n == 0:
            return 1

        if n < 0:
            n = -1 * n
            x = 1.0 / x

        result = 1
        while n != 0:
            if n % 2 == 1:
                result *= x
                n -= 1
            x *= x
            n //= 2
        return result
```

<ProblemComplexity tc="\(O(\log n)\)" sc="\(O(1)\)" />

---

<Problem
  title="162. Find Peak Element"
  link="https://leetcode.com/problems/find-peak-element/description/"
  difficulty="Medium"
  example={{
    input: "nums = [1,2,3,1]",
    output: "2",
    explanation: "3 is a peak element and your function should return the index number 2."
  }}
>

A **peak element** is an element that is **strictly greater** than its neighbors.

Given a **0-indexed** integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.

You may imagine that `nums[-1] = nums[n] = -âˆ`. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.

You must write an algorithm that runs in $O(\log n)$ time.

</Problem>

<div className="relative flex w-full">
  <div>
    Input array - [1, 2, 3, 2]
    <Image
      src="/algorithms-cheatsheet/162-chart.svg"
      width="320"
      height="202"
      alt="Example of input data 1"
    />
  </div>
  <div>
    Input array - [1, 2, 3]
    <Image
      src="/algorithms-cheatsheet/162-chart-2.svg"
      width="320"
      height="202"
      alt="Example of input data 2"
    />
  </div>
</div>

**Brute Force**

```py filename="162. Find Peak Element - Brute force"
def findPeakElement(nums):
    for i in range(len(nums) - 1):
        if nums[i] > nums[i + 1]:
            return i
    return len(nums) - 1
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

**Binary search - Iterative**

Hints:

- Local peak, not global
- Items behind array borders (behind first and last) are smaller than boundary items (first and last)

<Image
  src="/algorithms-cheatsheet/162-bin-search.svg"
  width="718"
  height="404"
  alt="Binary search conditions example"
/>

```py filename="162. Find Peak Element - Binary search - Iterative"
def findPeakElement(self, nums):
    l, r = 0, len(nums) - 1
    while l < r:
        mid = (l + r) // 2
        if nums[mid] > nums[mid + 1]:
            r = mid
        else:
            l = mid + 1
    return l
```

<ProblemComplexity tc="\(O(\log n)\)" sc="\(O(1)\)" />

</details>

<details>
<summary>

#### Additional materials

</summary>

- [LeetCode - Binary Search](https://leetcode.com/explore/learn/card/binary-search/)
- [LeetCode Discuss - A Noob's Guide to the Binary Search Algorithm](https://leetcode.com/discuss/study-guide/1233854/a-noobs-guide-to-the-binary-search-algorithm)
- [GitHub - Several Coding Patterns for Solving Data Structures and Algorithms Problems during Interviews](https://github.com/Chanda-Abdul/Several-Coding-Patterns-for-Solving-Data-Structures-and-Algorithms-Problems-during-Interviews/blob/main/%E2%9C%85%20%20Pattern%2011%3A%20Modified%20Binary%20Search.md)
- [USACO Guide - Binary Search (Python)](https://usaco.guide/silver/binary-search?lang=py)

</details>

## Dynamic Programming

**Dynamic programming** is a computer programming technique where an algorithmic problem is first broken down into sub-problems, the results are saved, and then the sub-problems are optimized to find the overall solution.

#### Why use DP?

- The problem can be divided by subproblems
- The subproblems are overlapping

#### 3 main components:

1. **State** - stores answer for i-th subproblem
2. **Transition between states** - how to get new solution based on previously calculated
3. **Base case**

#### Approaches

- **Top-Down** - try to solve main problem first, and to solve it solve subproblems recursively up to base case
- **Bottom-Up** - solve subproblems starting from the next one to base case and finishing on main problem

- **Push DP** - update future states based on the current state
- **Pull DP** - calculate the current state based on past states

#### Top-Down vs Bottom-Up

**Top-Down**

- Benefits: Easier to implement because of recursion
- Drawbacks: Could not be appliciable because of call stack overflow

**Bottom-Up**

- Benefits: No recursion. Sometimes is better in space than Top-Down
- Drawbacks: Harder to implement

#### Hints on using DP

- Think of Base case
- First try recursive Top-Bottom
- Then if Top-Bottom doesn't fit (because of recursive stack or to optimise space, or whatsoever) then try Bottom-Up

<details>
<summary>

#### Additional materials

</summary>

- [USACO Guide](https://usaco.guide/gold/intro-dp?lang=py)
- [Miro board with examples](https://miro.com/app/board/uXjVKsh2Zg4=/)

</details>
