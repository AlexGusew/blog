---
title: Algorithms and Data Structures Cheatsheet
description: A quick reference guide to some of the most commonly used algorithms in DSA
date: "2024-10-28"
---

<details>
<summary>

### Table of contents

</summary>

- [Two pointers](#two-pointers)
- [Sliding window](#sliding-window)
- [Intervals](#intervals)
- [Linked List](#linked-list)
- [Heap](#heap)
- [Two heaps](#two-heaps)
- [K-Way Merge](#k-way-merge)
- [Greedy](#greedy)
- [Dijkstra's shortest path](#dijkstras-shortest-path)
- [Dynamic Programming](#dynamic-programming)
- [Traversals](#traversals)
- [Matrix](#matrix)
- [Bonus](#bonus)

</details>

<details>
<summary>

### Definitions

</summary>

- **Search Space Tree** - tree of possible solutions generated on each iteration of algorithm. It's useful to think of your problem as Search-Space tree.

</details>

## Two pointers

<AlgorithmSummary tc={{ latex: "$$O(n)$$" }} sc={{ latex: "$$O(1)$$" }} />

Iterating two pointers across an array to search for a pair of indices satisfying some condition in linear time.

#### Types

- Opposite directional

  - <ProblemBadge difficulty="Medium" /> [167. Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/)
  - <ProblemBadge difficulty="Hard" /> [42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/description/)

- Same directional

  - <ProblemBadge difficulty="Easy" /> [26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)

- Fast and slow pointers
  - <ProblemBadge difficulty="Easy" /> [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/description/)
  - <ProblemBadge difficulty="Easy" /> [876. Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/description/)

#### When to use

- Sequential data structure (arrays, linked lists)
- Process pairs
- Remove duplicates from a sorted data
- Detect cycle in array
- Find a pair, triplet, or a subarray that satisfies a specific condition
- Reversing, partitioning, swapping, or rearranging
- String manipulation
- Array partitioning
- Etc. like Two sum or container with water variations

<details>
<summary>

#### Problem examples

</summary>

<br />

<Problem
  title="167. Two Sum II - Input Array Is Sorted"
  link="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description"
  difficulty="Medium"
>

Given a 1-indexed array of integers `numbers` that is already sorted in non-decreasing order, find two numbers such that they add up to a specific `target` number.

</Problem>

```py filename="167. Two Sum II - Input Array Is Sorted"
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        low = 0
        high = len(numbers) - 1
        while low < high:
            sum = numbers[low] + numbers[high]

            if sum == target:
                return [low + 1, high + 1]
            elif sum < target:
                low += 1
            else:
                high -= 1
        return [-1, -1]
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

---

<Problem
  title="876. Middle of the Linked List"
  link="https://leetcode.com/problems/middle-of-the-linked-list/description"
  difficulty="Easy"
>

Given the `head` of a singly linked list, return the middle node of the linked list.

If there are two middle nodes, return the second middle node.

</Problem>

```py filename="876. Middle of the Linked List"
class Solution:
    def middleNode(self, head):
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

---

<Problem
  title="42. Trapping Rain Water"
  link="https://leetcode.com/problems/trapping-rain-water/description"
  difficulty="Hard"
>

Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.

</Problem>

<Image
  src="/algorithms-cheatsheet/rain-water.png"
  width="718"
  height="404"
  alt="Trapping Rain Water example"
  priority={true}
/>

```py filename="42. Trapping Rain Water"
class Solution:
    def trap(self, height: List[int]) -> int:
        left, right = 0, len(height) - 1
        ans = 0
        left_max, right_max = 0, 0
        while left < right:
            if height[left] < height[right]:
                left_max = max(left_max, height[left])
                ans += left_max - height[left]
                left += 1
            else:
                right_max = max(right_max, height[right])
                ans += right_max - height[right]
                right -= 1
        return ans
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

</details>

<details>
<summary>

#### Additional materials

</summary>

- [Two Pointers · USACO Guide](https://usaco.guide/silver/two-pointers?lang=cpp)
- [Solved all two pointers problems in 100 days. - LeetCode Discuss](https://leetcode.com/discuss/study-guide/1688903/Solved-all-two-pointers-problems-in-100-days)
- [How to Solve Sliding Window Problems](https://medium.com/outco/how-to-solve-sliding-window-problems-28d67601a66)
- [Solved all two pointers problems in 100 days. - LeetCode Discuss](https://leetcode.com/discuss/study-guide/1688903/Solved-all-two-pointers-problems-in-100-days)
- [Algorithm Templates: Two Pointers](https://www.pluralsight.com/resources/blog/guides/algorithm-templates-two-pointers-part-1)
- [Two-Pointer Algorithm Explained: Practical Applications and Examples](<https://medium.com/@t.hasan.prince/two-pointer-algorithm-explained-practical-applications-and-examples-fc2c8bd137ca#:~:text=Array%20(%20path%20):%20This%20array,than%20targetSum%20%2C%20Alice%20moves%20forward.>)

</details>

## Sliding window

<AlgorithmSummary
  tc={{ latex: "$$O(n)$$" }}
  sc={{
    latex: (
      <ul>
        <li>\(O(1) - if\;only\;2\;pointers\;tracked\)</li>
        <li>\(O(w) - if\;window\;elements\;tracked\)</li>
      </ul>
    ),
  }}
/>

Maintain a **dynamic window** that slides through the array or string, adjusting its boundaries as needed to track relevant elements or characters.

Convert **multiple nested loops into single loop**, reducing the time complexity from $O(n²)$ or $O(n³)$ to $O(n)$.

#### Types

- **Fixed window size**
  - <ProblemBadge difficulty="Medium" /> [2461. Maximum Sum of Distinct Subarrays
    With Length K](https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/description/)
- **Variable window size**
  - Approach:
    - **Initialize window indices**: Start with `start` and `end` pointers at the first element.
    - **Expand the window**: Increment the `end` pointer to expand the window if conditions are met.
    - **Process the window**: Perform required operations when the window meets criteria.
    - **Adjust the window size**: Move the `start` pointer to adjust size and meet desired criteria.
  - <ProblemBadge difficulty="Medium" /> [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/description/)
- **Growing window**:
  - <ProblemBadge difficulty="Medium" /> [3. Longest Substring Without Repeating
    Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/)
  - <ProblemBadge difficulty="Medium" /> [904. Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/description/)
- **Shrinking window**
- **Multiple windows**: Maintaining overlapping or disjoint windows can help solve problems more efficiently.
  - <ProblemBadge difficulty="Hard" /> [992. Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/editorial/)

#### When to use

- **Contiguous** data: array, linked list, string, or stream
- Processing subsets of elements: The problem requires repeated computations on a **contiguous subset** of data elements (a subarray or a substring) of **fixed** or **variable** length
- Find longest, shortest or target values of a sequence

#### Problem patterns

1. **Running Average**: Efficiently calculate the average of a fixed-size window in a data stream.
1. **Formulating Adjacent Pairs**: Process adjacent pairs in an ordered structure for easy access and operation.
1. **Target Value Identification**: Adjust window size to search efficiently for specific values or subarrays.
1. **Longest/Shortest/Most Optimal Sequence**: Identify the desired sequence in a collection by sliding a window through it.

<details>
<summary>

#### Real World usage

</summary>

- **String Manipulation**:
  - Substring Search: Finding the longest substring without repeating characters.
  - Pattern Matching: Searching for a pattern within a larger string efficiently.
  - Text Processing: Analyzing text data for specific patterns or occurrences.
- **Array Manipulation**:
  - Subarray Problems: Finding the maximum sum, product, or average of a subarray of fixed or variable size.
  - Data Processing: Analyzing time series data, such as stock prices or sensor readings, to identify trends or anomalies.
- **Window-based Algorithms**:

  - Sliding Window Aggregations: Calculating moving averages, rolling sums, or other window-based aggregations in data analysis.
  - Stream Processing: Handling data streams by maintaining a sliding window over the stream to perform computations in real-time.

- **Data Compression**:
  - Sliding window compression algorithms, like [LZ77](https://en.wikipedia.org/wiki/LZ77_and_LZ78) and its variants, use a window to find repeated patterns in the input data and replace them with references to previous occurrences.
- **Image Processing**:
  - In image processing, a sliding window can be employed for tasks such as feature extraction, object detection, or image segmentation.
- **Signal Processing**:
  - Time-series data can be analyzed using a sliding window to capture local patterns, trends, or anomalies.
- **Network Traffic Analysis**:
  - Anomaly Detection: Identifying anomalous patterns in network traffic by analyzing data within sliding windows.
  - Performance Monitoring: Monitoring network performance metrics, such as latency or throughput, over time using sliding windows.
- **Optimization Problems**:
  - Resource Allocation: Optimizing resource allocation or scheduling decisions based on dynamic window-based constraints.
- **Natural Language Processing (NLP)**:
  - Text Classification: Analyzing text documents and classifying them into categories based on sliding window features.
  - Named Entity Recognition: Identifying entities such as names, locations, or organizations within text using sliding window-based algorithms.

</details>

<details>
<summary>

#### Problem examples

</summary>

<br />

<Problem 
  title="904. Fruit Into Baskets" 
  link="https://leetcode.com/problems/fruit-into-baskets/description/"
  difficulty="Medium"
  example={{
    input: "fruits = [0,1,2,2]",
    output: "3",
    explanation: "We can pick from trees [1,2,2]. If we had started at the first tree, we would only pick from trees [0,1]."
}}
>
You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array `fruits` where `fruits[i]` is the type of fruit the ith tree produces.

You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:

- You only have **two** baskets, and each basket can only hold a **single type** of fruit. There is **no limit** on the amount of fruit each basket can hold.
- **Starting from any tree** of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked `fruits` **must** fit in one of your baskets.
- Once you reach a tree with fruit that cannot fit in your baskets, you must **stop**.
- Given the integer array `fruits`, return the **maximum number** of `fruits` you can pick.

</Problem>

<Image
  src="/algorithms-cheatsheet/904.png"
  width="718"
  height="404"
  alt="Fruit Into Baskets Example"
  priority={true}
/>

Let's compare **Brute Force** approach with **Sliding window**.

In second approach, we **converted two nested loops into a single loop** thus improving Time Complexity from $O(n^2)$ to $O(n)$:

```py filename="904. Fruit Into Baskets. Brute Force approach"
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        max_picked = 0

        for left in range(len(fruits)):
            basket = set()
            right = left

            while right < len(fruits):
                if fruits[right] not in basket and len(basket) == 2:
                    break
                basket.add(fruits[right])
                right += 1

            max_picked = max(max_picked, right - left)
        return max_picked
```

<ProblemComplexity tc="\(O(n^2)\)" sc="\(O(1)\)" />

---

```py filename="904. Fruit Into Baskets. Sliding window approach"
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        basket = {}
        max_picked = 0
        left = 0

        for right in range(len(fruits)):
            basket[fruits[right]] = basket.get(fruits[right], 0) + 1

            while len(basket) > 2:
                basket[fruits[left]] -= 1
                if basket[fruits[left]] == 0:
                    del basket[fruits[left]]
                left += 1

            max_picked = max(max_picked, right - left + 1)
        return max_picked
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

---

<Problem 
  title="2461. Maximum Sum of Distinct Subarrays With Length K" 
  link="https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/description/"
  difficulty="Medium"
    example={{
    input: "nums = [1,5,4,2,9,9,9], k = 3",
    output: "15",
    explanation: "The subarray of length 3 with max sum of 15 is [4,2,9]"
}}
>
You are given an integer array `nums` and an integer `k`. Find the maximum subarray sum of all the subarrays of nums that meet the following conditions:

- The length of the subarray is `k`
- All the elements of the subarray are **distinct**.

Return the **maximum subarray sum** of all the subarrays that meet the conditions.
If no subarray meets the conditions, return **0**.

</Problem>

```py filename="2461. Maximum Sum of Distinct Subarrays With Length K"
class Solution:
    def maximum_subarray_sum(self, nums, k):
        res = cur_sum = 0
        last_seen_to_idx = {}
        last_seen = -1

        for i, num in enumerate(nums):
            cur_sum += num
            if i >= k:
                cur_sum -= nums[i - k]
            last_seen = max(last_seen, last_seen_to_idx.get(num, -1))
            if i - last_seen >= k:
                res = max(res, cur_sum)
            last_seen_to_idx[num] = i

        return res
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(n)\)" />

---

<Problem
  title="209. Minimum Size Subarray Sum"
  link="https://leetcode.com/problems/minimum-size-subarray-sum/description"
  difficulty="Medium"
  example={{
    input: "target = 7, nums = [2,3,1,2,4,3]",
    output: "2",
    explanation:
      "The subarray [4,3] has the minimal length under the problem constraint.",
  }}
>
  Given an array of positive integers `nums` and a positive integer `target`,
  return the minimal length of a subarray whose sum is greater than or equal to
  `target`. If there is no such subarray, return `0` instead.
</Problem>

```py filename="209. Minimum Size Subarray Sum"
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        left = 0
        right = 0
        sumOfCurrentWindow = 0
        res = float('inf')

        for right in range(0, len(nums)):
            sumOfCurrentWindow += nums[right]

            while sumOfCurrentWindow >= target:
                res = min(res, right - left + 1)
                sumOfCurrentWindow -= nums[left]
                left += 1

        return res if res != float('inf') else 0
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

---

<Problem
  title="1456. Maximum Number of Vowels in a Substring of Given Length"
  link="https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/"
  difficulty="Medium"
  example={{
    input: "s = \"abciiidef\", k = 3",
    output: "3",
    explanation:
      "The substring \"iii\" contains 3 vowel letters.",
  }}
>

Given a string `s` and an integer `k`, return the maximum number of vowel letters in any substring of s with length `k`.

</Problem>

```py filename="1456. Maximum Number of Vowels in a Substring of Given Length"
class Solution:
    def maxVowels(self, s: str, k: int) -> int:
        vowels = set("aeiou")
        count = 0
        for i in range(k):
            count += int(s[i] in vowels)
        answer = count
        for i in range(k, len(s)):
            count += int(s[i] in vowels)
            count -= int(s[i - k] in vowels)
            answer = max(answer, count)

        return answer
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

</details>

<details>
<summary>

#### Additional materials

</summary>

- [Sliding Window - USACO Guide](https://usaco.guide/gold/sliding-window?lang=py)
- [Mastering Sliding Window Techniques | by Ankit Singh | Medium](https://medium.com/@rishu__2701/mastering-sliding-window-techniques-48f819194fd7)
- [Sliding Window Technique: A Comprehensive Guide - LeetCode Discuss](https://leetcode.com/discuss/interview-question/3722472/mastering-sliding-window-technique-a-comprehensive-guide)

</details>

## Intervals

<AlgorithmSummary tc={{ latex: "$$O(n)$$" }} sc={{ latex: "$$O(1)$$" }} />

Typical interval problem deals with **array of overlapping intervals** e.g. `[[1, 3], [3, 5]]`

Common tasks with intervals:

- Merging intersecting intervals
  - <ProblemBadge difficulty="Medium" /> [https://leetcode.com/problems/merge-intervals/description/](https://leetcode.com/problems/merge-intervals/description/)
- Inserting new intervals into existing sets
  - <ProblemBadge difficulty="Medium" /> [57. Insert Interval](https://leetcode.com/problems/insert-interval/description/)
- Schedule tasks
  - <ProblemBadge difficulty="Medium" /> [621. Task Scheduler](https://leetcode.com/problems/task-scheduler/description/)
- Arrange meeting rooms
  - <ProblemBadge difficulty="Medium" /> [253. Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/description/)
- Determining the minimum number of intervals needed to cover a given range

#### Corner cases

- No intervals
- Single interval
- Two intervals
- Non-overlapping intervals
- An interval totally consumed within another interval
- Duplicate intervals (exactly the same start and end)
- Intervals which start right where another interval ends - `[[1, 2], [2, 3]]`

#### When to use

- Given intervals
- Find union / intersection / gaps

<details>
<summary>

#### Real World usage

</summary>

- **Event scheduling**
- **Resource allocation**: Schedule tasks for the OS based on task priority and the free slots in the machine’s processing schedule
- **Time slot consolidation**

</details>
<details>
<summary>
#### Problem examples

</summary>

<br />

<Problem
  title="56. Merge Intervals"
  link="https://leetcode.com/problems/merge-intervals/description/"
  difficulty="Medium"
  example={{
    input: "intervals = [[1,3], [2,6], [8,10], [15,18]]",
    output: "[[1,6], [8,10], [15,18]]",
    explanation: "Since intervals [1,3] and [2,6] overlap, merge them into [1,6].",
  }}
>

Given an array of intervals where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.

</Problem>

```py filename="56. Merge Intervals"
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key=lambda x: x[0])
        merged = []

        for interval in intervals:
            if not merged or merged[-1][1] < interval[0]:
                merged.append(interval)
            else:
                merged[-1][1] = max(merged[-1][1], interval[1])

        return merged
```

<ProblemComplexity
  tc="\(O(n*log(n))\)"
  sc="\(O(n)\) or \(O(log(n))\) depending on sorting algorithm"
/>

---

<Problem
  title="57. Insert Interval"
  link="https://leetcode.com/problems/insert-interval/description/"
  difficulty="Medium"
    example={{
    input: "intervals = [[1,2], [3,5], [6,7], [8,10], [12,16]], newInterval = [4,8]",
    output: "[[1,2], [3,10], [12,16]]",
    explanation: "Because the new interval [4,8] overlaps with [3,5], [6,7], [8,10].",
  }}
>

You are given an array of non-overlapping intervals `intervals` where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> represent the start and the end of the <code>i<sup>th</sup></code> interval and `intervals` is sorted in ascending order by <code>start<sub>i</sub></code>. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval.

Insert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by <code>start<sub>i</sub></code> and `intervals` still does not have any overlapping intervals (**merge** overlapping intervals if necessary).

Return intervals after the insertion.

Note that you don't need to modify intervals in-place. You can make a new array and return it.

</Problem>

Problem can be dropped down into 2 subproblems:

1. Find correct place for `newInterval`
   - Since `intervals` is sorted, we can utilize binary search.
2. Merge it with any overlapping intervals
   - Linear iteration over intervals

```py filename="57. Insert Interval"
class Solution:
    def insert(
        self, intervals: List[List[int]], newInterval: List[int]
    ) -> List[List[int]]:
        # If the intervals vector is empty, return a vector containing the newInterval
        if not intervals:
            return [newInterval]

        n = len(intervals)
        target = newInterval[0]
        left, right = 0, n - 1

        # Binary search to find the position to insert newInterval
        while left <= right:
            mid = (left + right) // 2
            if intervals[mid][0] < target:
                left = mid + 1
            else:
                right = mid - 1

        # Insert newInterval at the found position
        intervals.insert(left, newInterval)

        # Merge overlapping intervals
        res = []
        for interval in intervals:
            # If res is empty or there is no overlap, add the interval to the result
            if not res or res[-1][1] < interval[0]:
                res.append(interval)
            # If there is an overlap, merge the intervals by updating the end of the last interval in res
            else:
                res[-1][1] = max(res[-1][1], interval[1])
        return res
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(n)\)" />

---

<Problem
  title="621. Task Scheduler"
  link="https://leetcode.com/problems/task-scheduler/description/"
  difficulty="Medium"
  example={{
    input: `tasks = ["A","A","A","B","B","B"], n = 2`,
    output: "8",
    explanation: <span>A possible sequence is: <code>A → B → idle → A → B → idle → A → B</code>.<br/> After completing task <i>A</i>, you must wait two intervals before doing <i>A</i> again. The same applies to task <i>B</i>. In the 3 interval, neither <i>A</i> nor <i>B</i> can be done, so you <i>idle</i>. By the 4 interval, you can do <i>A</i> again as 2 intervals have passed.</span>
}}

>

You are given an array of CPU `tasks`, each labeled with a letter from A to Z, and a number `n`. Each CPU interval can be idle or allow the completion of one task. Tasks can be completed in any order, but there's a **constraint**:
There has to be a gap of at least `n` intervals between two tasks with the same label.

Return the **minimum number** of CPU intervals required to complete all `tasks`.

</Problem>

```py filename="621. Task Scheduler"
class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        counter = Counter(tasks)
        max_heap = [-val for val in counter.values()]
        heapify(max_heap)
        res = 0
        while max_heap:
            cycle = n + 1
            tasks = []
            while cycle and max_heap:
                task = -heappop(max_heap)
                cycle -= 1
                if task > 1:
                    tasks.append(-(task - 1))
            while tasks:
                heappush(max_heap, tasks.pop())
            res += n + 1 if max_heap else n - cycle + 1

        return res
```

<ProblemComplexity
  tc="\(O(n*log(26)) \rightarrow O(n)\)"
  sc="\(O(26) \rightarrow O(1)\)"
/>

---

<Problem
  title="253. Meeting Rooms II"
  link="https://leetcode.com/problems/meeting-rooms-ii/description/"
  difficulty="Medium"
>

Given an array of meeting time intervals `intervals` where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, return the **minimum number of conference rooms** required.

</Problem>

```py filename="253. Meeting Rooms II"
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        intervals.sort()
        end_times = []
        for start, end in intervals:
            if not end_times or end_times[0] > start:
                heapq.heappush(end_times, end)
            else:
                heapq.heapreplace(end_times, end)

        return len(end_times)
```

<ProblemComplexity tc="\(O(n*log(n))\)" sc="\(O(n)\)" />

</details>

<details>
<summary>

#### Additional materials

</summary>

- [Interval cheatsheet for coding interviews](https://www.techinterviewhandbook.org/algorithms/interval/)
- [Merge Intervals](https://www.educative.io/courses/grokking-coding-interview/merge-intervals)

</details>

## Linked List

<AlgorithmSummary
  tc={{
    latex: (
      <ul>
        <li>\(Insert, Remove - O(1)\)</li>
        <li>\(Get\;by\;index, Search - O(n)\)</li>
      </ul>
    ),
  }}
  sc={{ latex: "$$O(1)$$" }}
/>

This section focuses on **in-place** operations with Linked Lists.

#### Properties

- Sequential data structure (like array, unlike tree)
- Slow access, but fast add / delete operations

#### Types

- Singly-linked list
- Doubly-linked list
- Circular-linked list

#### Example of Linked List

```py filename="Typical ListNode in LeetCode"
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

first_node = ListNode(1)
second_node = ListNode(2)

first_node.next = second_node
```

```py
┌─────┐    ┌─────┐
│  1  ┼───►│  2  ┼───x
└─────┘    └─────┘
```

#### Dummy node technique

If operation is going to be performed on head or tail node, we can create `dummy` node, and point `dummy.next` to `head`. It helps not to handle edge cases for head only:

```py filename="dummy node usage example"
dummy = ListNode()
dummy.next = head

# perform operations on dummy.next
# we don't need to handle head specifically

return dummy.next
```

#### Typical operations with Linked Lists

- **List Node operations**
  - Swap nodes <ProblemBadge difficulty="Medium" /> [1721. Swapping Nodes in a Linked List](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/description/)
  - Remove node <ProblemBadge difficulty="Medium" /> [237. Delete Node in a Linked List](https://leetcode.com/problems/delete-node-in-a-linked-list/description/)
- **Whole List operations**
  - Reverse <ProblemBadge difficulty="Easy" /> [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/description/)
  - Reorder <ProblemBadge difficulty="Medium" /> [143. Reorder List](https://leetcode.com/problems/reorder-list/description/)
  - Split <ProblemBadge difficulty="Medium" /> [725. Split Linked List in Parts](https://leetcode.com/problems/split-linked-list-in-parts/description/)
  - Merge 2 or more lists <ProblemBadge difficulty="Hard" /> [23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/description/)
- **Search**
  - Find middle <ProblemBadge difficulty="Easy" /> [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/description/)
  - Find cycle <ProblemBadge difficulty="Easy" /> [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/description/)
- **Custom data structures** with Linked List under the hood
  - <ProblemBadge difficulty="Medium" /> [146. LRU Cache](https://leetcode.com/problems/lru-cache/description/)
  - <ProblemBadge difficulty="Hard" /> [460. LFU Cache](https://leetcode.com/problems/lfu-cache/description/)

#### When to use

- **Linked list restructuring**: The input data is given as a linked list, and the task is to modify its structure without modifying the data of the individual nodes.
- **In-place modification**: The modifications to the linked list must be made in place, that is, we’re not allowed to use more than $O(1)$ additional space.

<details>
<summary>

#### Problem examples

</summary>

<br />

<Problem
  title="206. Reverse Linked List"
  link="https://leetcode.com/problems/reverse-linked-list/description/"
  difficulty="Easy"
>

Given the `head` of a singly linked list, reverse the list, and return the reversed list.

</Problem>

**Iterative approach**

```py filename="206. Reverse Linked List - Iterative"
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        prev = None
        curr = head
        while curr:
            next_temp = curr.next
            curr.next = prev
            prev = curr
            curr = next_temp

        return prev
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

**Recursive approach**

Note: Space complexity grows to $O(n)$ because each `head` is stored in call stack.

```py filename="206. Reverse Linked List - Recursive"
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if (not head) or (not head.next):
            return head

        p = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return p
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(n)\)" />

---

<Problem
  title="141. Linked List Cycle"
  link="https://leetcode.com/problems/linked-list-cycle/description/"
  difficulty="Easy"
>

Given `head`, the head of a linked list, determine if the linked list has a **cycle** in it.

Return `true` if there is a cycle in the linked list. Otherwise, return `false`.

```py
┌─────┐    ┌─────┐    ┌─────┐
│  1  ┼───►│  2  ┼───►│  3  ┼─┐
└─────┘    └─────┘    └─────┘ │
  ▲                           │
  └───────────────────────────┘
```

</Problem>

```py filename="141. Linked List Cycle - Floyd's Cycle Finding Algorithm"
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        if head is None:
            return False
        slow = head
        fast = head.next
        while slow != fast:
            if fast is None or fast.next is None:
                return False
            slow = slow.next
            fast = fast.next.next
        return True
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

---

<Problem
  title="143. Reorder List"
  link="https://leetcode.com/problems/reorder-list/description/"
  difficulty="Medium"
>

You are given the `head` of a singly linked-list. The list can be represented as:

**L<sub>0</sub> → L<sub>1</sub> → … → L<sub>n - 1</sub> → L<sub>n</sub>**

Reorder the list to be on the following form:

**L<sub>0</sub> → L<sub>n</sub> → L<sub>1</sub> → L<sub>n - 1</sub> → L<sub>2</sub> → L<sub>n - 2</sub> → …**

You may not modify the values in the list's nodes. Only nodes themselves may be changed.

**Visual algorithm**

```py
1. Initial list:
┌─────┐    ┌─────┐    ┌─────┐    ┌─────┐    ┌─────┐
│  1  ┼───►│  2  ┼───►│  3  ┼───►│  4  ┼───►│  5  ┼───►null
└─────┘    └─────┘    └─────┘    └─────┘    └─────┘

2. Find middle (middle points to 3):
┌─────┐    ┌─────┐    ┌─────┐    ┌─────┐    ┌─────┐
│  1  ┼───►│  2  ┼───►│  3  ┼───►│  4  ┼───►│  5  ┼───►null
└─────┘    └─────┘    └─────┘    └─────┘    └─────┘
                         ▲
                      middle

3. Reverse second half (4->5 becomes 5->4):
┌─────┐    ┌─────┐    ┌─────┐    ┌─────┐    ┌─────┐
│  1  ┼───►│  2  ┼───►│  3  ┼───►│  4  ◄────│  5  │
└─────┘    └─────┘    └─────┘    └─────┘    └─────┘
                                             prev

4. Start merging (first=1, second=5):
┌─────┐    ┌─────┐    ┌─────┐    ┌─────┐    ┌─────┐
│  1  ┼─┐  │  2  ┼───►│  3  ┼───►│  4  ◄────│  5  │
└─────┘ │  └─────┘    └─────┘    └─────┘    └─────┘
        │                                       ▲
        └───────────────────────────────────────┘

5. Final reordered list:
┌─────┐    ┌─────┐    ┌─────┐    ┌─────┐    ┌─────┐
│  1  ┼───►│  5  ┼───►│  2  ┼───►│  4  ┼───►│  3  ┼───►null
└─────┘    └─────┘    └─────┘    └─────┘    └─────┘
```

</Problem>

```py filename="143. Reorder List"
class Solution:
    def reorderList(self, head: ListNode) -> None:
        if not head:
            return

        # find the middle of linked list [Problem 876]
        # in 1->2->3->4->5->6 find 4
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        # reverse the second part of the list [Problem 206]
        # convert 1->2->3->4->5->6 into 1->2->3->4 and 6->5->4
        # reverse the second half in-place
        prev, curr = None, slow
        while curr:
            curr.next, prev, curr = prev, curr, curr.next

        # merge two sorted linked lists [Problem 21]
        # merge 1->2->3->4 and 6->5->4 into 1->6->2->5->3->4
        first, second = head, prev
        while second.next:
            first.next, first = second, first.next
            second.next, second = first, second.next
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

</details>

<details>
<summary>

#### Additional materials

</summary>

- [Become Master In Linked List - LeetCode Discuss](https://leetcode.com/discuss/study-guide/1800120/become-master-in-linked-list)
- [What’s a Linked List, Anyway? [Part 1] | by Vaidehi Joshi | basecs | Medium](https://medium.com/basecs/whats-a-linked-list-anyway-part-1-d8b7e6508b9d)
- [Linked list cheatsheet for coding interviews](https://www.techinterviewhandbook.org/algorithms/linked-list/)

</details>

## Heap

<AlgorithmSummary
  tc={{
    latex: (
      <ul>
        <li>\(Find\;Min / Max - O(1)\)</li>
        <li>\(Insert, Remove - O(log(n))\)</li>
        <li>\(Heapify - O(n)\)</li>
      </ul>
    ),
  }}
  sc={{ latex: "$$O(1)$$" }}
/>

Heap is a **complete binary tree** where each node is smaller than its children (for min heap). This property is called **Heap invariant**.

Heap must always comply to **Heap invariant**

#### Priority Queue vs Heap

- Priority queue
  - Abstract data structure (like stack or queue) that behaves like queue (First In, First Out)
  - Specifies behavior of data structure
  - Doesn't define internal implementation
  - Each element has **priority** - the higher propriety element comes first
- Heap
  - Implementation of Priority queue

#### Types

- **Min heap** - each parent node **smaller of equal** to its children
- **Max heap** - each parent node **bigger or equal** to its children

#### Operations on heap

- **Add node**
  1. Add new node to end of heap
  2. Swap the node with parent if it's bigger than parent
  3. At most, $O(log(n))$ swaps could be made since heap - **Complete binary tree**. In complete binary tree, height = `log(n)`
- **Remove node**
  1. Take tree root and remove it from tree
  2. Place last element to root
  3. Swap with children to achieve **Heap invariant**
  4. At most, $O(log(n))$ swaps could be made
- **Heapify**
  1. Start from last leave
  2. If node doesn't satisfy **Heap invariant**, recursively heapify subtree
  3. Move up the tree until the entire tree satisfies the **Heap invariant**
  4. The total amount of swaps is $O(n)$

#### Array representation of Heap

Heap usually represented as array:

- Node<sub>i</sub> stored in array by index `i`
- Node<sub>i</sub> left and right children could be found by index `2 * i` and `2 * i + 1`
- It's convenient to store nodes starting from index `1`

#### Example

- Max heap
- Complete binary tree with height of 2

**Tree** representation:

```py
Level             Tree

  0:                9
                  /   \
  1:             7     8
                /
  2:           5
```

**Array** representation with indices:

```py
        ┌───┬───┬───┬───┬───┐
Value   │ - │ 9 │ 7 │ 8 │ 5 │
        └───┴───┴───┴───┴───┘
Index     0   1   2   3   4
```

#### When to use

- K-th element

  - <ProblemBadge difficulty="Medium" /> [Kth Largest Element in an Array (Problem
    215)](https://leetcode.com/problems/kth-largest-element-in-an-array/)
  - <ProblemBadge difficulty="Medium" /> [Kth Smallest Element in a Sorted Matrix
    (Problem 378)](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)

- Top K elements

  - <ProblemBadge difficulty="Medium" /> [Top K Frequent Elements (Problem 347)](https://leetcode.com/problems/top-k-frequent-elements/)
  - <ProblemBadge difficulty="Medium" /> [K Closest Points to Origin (Problem 973)](https://leetcode.com/problems/k-closest-points-to-origin/)

- Heap sort

  - <ProblemBadge difficulty="Medium" /> [Sort an Array (Problem 912)](https://leetcode.com/problems/sort-an-array/)

- Sort subset of elements resulting to TC optimization from $O(n*log(n))$ to $O(n*log(k))$ where k is heap size
  - <ProblemBadge difficulty="Medium" /> [Find K Pairs with Smallest Sums (Problem
    373)](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/)
  - <ProblemBadge difficulty="Hard" /> [Merge k Sorted Lists (Problem 23)](https://leetcode.com/problems/merge-k-sorted-lists/)

<details>
<summary>

#### Problem examples

</summary>

<br />

<Problem
  title="215. Kth Largest Element in an Array"
  link="https://leetcode.com/problems/kth-largest-element-in-an-array/description/"
  difficulty="Medium"
  example={{
    input: "nums = [3,2,1,5,6,4], k = 2",
    output: "5"
  }}
>

Given an integer array `nums` and an integer `k`, return the <code>k<sub>th</sub></code> largest element in the array.

Note that it is the <code>k<sub>th</sub></code> largest element in the sorted order, not the <code>k<sub>th</sub></code> distinct element.

Can you solve it without sorting?

</Problem>

```py filename="215. Kth Largest Element in an Array"
class Solution:
    def findKthLargest(self, nums, k):
        heap = []
        for num in nums:
            heapq.heappush(heap, num)
            if len(heap) > k:
                heapq.heappop(heap)

        return heap[0]
```

<ProblemComplexity tc="\(O(n*log(k))\)" sc="\(O(k)\)" />

---

<Problem
  title="347. Top K Frequent Elements"
  link="https://leetcode.com/problems/top-k-frequent-elements/description/"
  difficulty="Medium"
  example={{
    input: "nums = [1,1,1,2,2,3], k = 2",
    output: "[1,2]"
  }}
>

Given an integer array `nums` and an integer `k`, return the `k` most frequent elements. You may return the answer in any order.

</Problem>

```py filename="347. Top K Frequent Elements"
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        heap = []
        for num, freq in Counter(nums).items():
            heapq.heappush(heap, (freq, num))
            if len(heap) > k:
                heapq.heappop(heap)
        return [num for freq, num in heap]
```

<ProblemComplexity tc="\(O(n*log(k))\)" sc="\(O(n + k)\)" />

---

<Problem
  title="373. Find K Pairs with Smallest Sums"
  link="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description"
  difficulty="Medium"
  example={{
    input: "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
    output: "[[1,2],[1,4],[1,6]]",
    explanation: "The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]"
  }}
>

You are given two integer arrays `nums1` and `nums2` sorted in non-decreasing order and an integer `k`.

Define a pair `(u, v)` which consists of one element from the first array and one element from the second array.

Return the `k` pairs <code>(u<sub>1</sub>, v<sub>1</sub>), (u<sub>2</sub>, v<sub>2</sub>), ..., (u<sub>k</sub>, v<sub>k</sub>)</code> with the **smallest sums**.

</Problem>

```py filename="373. Find K Pairs with Smallest Sums"
class Solution:
   def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
       heap, seen, res = [(nums1[0] + nums2[0], 0, 0)], {(0, 0)}, []
       while heap and len(res) < k:
           _, i, j = heappop(heap)
           res.append([nums1[i], nums2[j]])
           for i2, j2 in [(i, j + 1), (i + 1, j)]:
               if i2 < len(nums1) and j2 < len(nums2) and (i2, j2) not in seen:
                   seen.add((i2, j2))
                   heappush(heap, (nums1[i2] + nums2[j2], i2, j2))
       return res
```

Here, $m$ is the size of `nums1` and $n$ is the size of `nums2`:

<ProblemComplexity
  tc="\(O(min(k*log(k),m*n*log(m*n)))\)"
  sc="\(O(min(k,m*n))\)"
/>

</details>

<details>
<summary>

#### Real World usage

</summary>

- **Network routing**
  - Dijkstra's algorithm uses heaps to efficiently find the shortest path between network nodes by maintaining shortest distances as priorities.
- **Process scheduling**
  - Operating systems use priority queues (heaps) to manage which process gets CPU time next based on priority levels.
- **Resource allocation**
  - In cloud computing, heaps help distribute resources (like memory or CPU) by maintaining a priority queue of requests from different applications.
- **Machine learning**
  - K-nearest neighbors algorithm uses heaps to efficiently maintain the k closest points during distance calculations and similarity searches.

</details>

<details>
<summary>

#### Additional materials

</summary>

- [Competitive Programmer's Handbook - Chapter 9: Data Structures](https://usaco.guide/CPH.pdf#page=87)
- [Tech Interview Handbook - Heap](https://www.techinterviewhandbook.org/algorithms/heap/)
- [basecs - Learning to Love Heaps](https://medium.com/basecs/learning-to-love-heaps-cef2b273a238)
- [basecs - Heapify All The Things With Heap Sort](https://medium.com/basecs/heapify-all-the-things-with-heap-sort-55ee1c93af82)
- [Yale University - Heaps](https://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#heaps)
- [LeetCode - Master Heap: Understanding 4 Patterns Where Heap Data Structure is Used](https://leetcode.com/discuss/general-discussion/1127238/master-heap-understanding-4-patterns-where-heap-data-structure-is-used)
- [LeetCode - Heap Explore Card](https://leetcode.com/explore/featured/card/heap/)

</details>

## Two heaps

<AlgorithmSummary
  tc={{ latex: "$$O(n*log(k))$$" }}
  sc={{ latex: "$$O(k)$$" }}
/>

Two heaps approach used to find out middle of moving dataset

- <ProblemBadge difficulty="Hard" /> [295. Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/description/)
- <ProblemBadge difficulty="Hard" /> [480. Sliding Window Median](https://leetcode.com/problems/sliding-window-median/description/)

It assumes having

- **Max heap** to store maximum of part of dataset
- **Min heap** to store minimum of part of dataset

#### Algorithm for finding **median** of `k`-size dataset

- **Initialization** - placing elements to heaps by $O(k*log(k))$
  1. Initialize **min heap** and **max heap**
     - **Min heap** will store elements right to the median (bigger)
     - **Max heap** will store elements left to the median (smaller)
  2. Place every item in **min heap**
  3. If **min heap** size exceeds `k // 2`
     - Pop element from **min heap** (it will be smallest one)
     - Place to **max heap**
- **Find median** - $O(1)$
  - `k` even - Average of **min heap** and **max heap** roots
  - `k` odd - **Max heap** root
- **Shift sliding window**
  - Perform steps **2-3**

#### When to use

- **Linear data**: The input data is linear but not sorted
- **Stream of data**
- **Find Max / Min**:
  - Find maximums / minimums / maximum and minimum of 2 datasets

<details>
<summary>

#### Problem examples

</summary>

<br />

<Problem
  title="502. IPO"
  link="https://leetcode.com/problems/ipo/"
 difficulty="Hard"
  example={{
    input: "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
    output: "4",
    explanation: <span>Since your initial capital is 0, you can only start the project indexed 0.
After finishing it you will obtain profit 1 and your capital becomes 1.
With capital 1, you can either start the project indexed 1 or the project indexed 2.
Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.
Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.</span>
  }}>

Suppose LeetCode will start its **IPO** soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at **most k distinct** projects before the IPO. Help LeetCode design the best way to **maximize** its total capital after finishing at **most k distinct** projects.

You are given `n` projects where the <code>i<sub>th</sub></code> project has a pure profit `profits[i]` and a minimum capital of `capital[i]` is needed to start it.

Initially, you have `w` capital. When you finish a project, you will obtain its pure profit and the profit will be added to your **total capital**.

Pick a list of at most `k` distinct projects from given projects to **maximize** your final capital, and return the final maximized capital.

The answer is guaranteed to fit in a 32-bit signed integer.

</Problem>

```py filename="502. IPO"
class Solution:
    def findMaximizedCapital(
        self, k: int, w: int, profits: List[int], capital: List[int]
    ) -> int:
        min_capitals = [(c, p) for c, p in zip(capital, profits)]
        heapq.heapify(min_capitals)
        max_profits = []
        for _ in range(k):
            while min_capitals and min_capitals[0][0] <= w:
                c, p = heapq.heappop(min_capitals)
                heapq.heappush(max_profits, -p)
            if max_profits:
                w += -heapq.heappop(max_profits)
        return w
```

<ProblemComplexity tc="\(O(n*log(n))\)" sc="\(O(n)\)" />

---

<Problem
  title="480. Sliding Window Median"
  link="https://leetcode.com/problems/sliding-window-median/description/"
  difficulty="Hard"
  example={{
    input: "nums = [1,3,-1,-3,5,3,6,7], k = 3",
    output: "[1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]",
    explanation: <pre>
<code>Window position                Median</code><br/>
<code>---------------                -----</code><br/>
<code>[1  3  -1] -3  5  3  6  7        1</code><br/>
<code> 1 [3  -1  -3] 5  3  6  7       -1</code><br/>
<code> 1  3 [-1  -3  5] 3  6  7       -1</code><br/>
<code> 1  3  -1 [-3  5  3] 6  7        3</code><br/>
<code> 1  3  -1  -3 [5  3  6] 7        5</code><br/>
<code> 1  3  -1  -3  5 [3  6  7]       6</code>
</pre>
  }}
>

The **median** is the middle value in an ordered integer list. If the size of the list is **even**, there is no middle value. So the median is the mean of the two middle values.

- For examples, if <code>arr = [2,<u>3</u>,4]</code>, the median is `3`.
- For examples, if <code>arr = [1,<u>2,3</u>,4]</code>, the median is `(2 + 3) / 2 = 2.5`.

You are given an integer array `nums` and an integer `k`. There is a **sliding window** of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.

Return the **median** array for each window in the original array. Answers within 10-5 of the actual value will be accepted.

</Problem>

```py filename="480. Sliding Window Median"
class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        def clean(h, is_min):
            while h and rm.get(h[0] if is_min else -h[0], 0):
                rm[h[0] if is_min else -h[0]] -= 1
                heapq.heappop(h)

        rm, lo, hi, res = {}, [], [], []
        for i in range(k):
            heapq.heappush(lo, -nums[i])
        for _ in range(k // 2):
            heapq.heappush(hi, -heapq.heappop(lo))

        for i in range(k, len(nums) + 1):
            res.append(-lo[0] if k % 2 else (-lo[0] + hi[0]) / 2)
            if i == len(nums):
                break

            out, in_num = nums[i - k], nums[i]
            rm[out] = rm.get(out, 0) + 1
            bal = -1 if out <= -lo[0] else 1

            if lo and in_num <= -lo[0]:
                heapq.heappush(lo, -in_num)
                bal += 1
            else:
                heapq.heappush(hi, in_num)
                bal -= 1

            if bal < 0:
                heapq.heappush(lo, -heapq.heappop(hi))
            if bal > 0:
                heapq.heappush(hi, -heapq.heappop(lo))
            clean(lo, False)
            clean(hi, True)

        return res
```

<ProblemComplexity tc="\(O(n*log(k))\)" sc="\(O(k)\)" />

</details>

<details>
<summary>

#### Additional materials

</summary>

- [Introduction to Two Heaps](https://www.educative.io/courses/grokking-coding-interview/introduction-to-two-heaps)
- [GitHub - Pattern 09: Two Heaps](https://github.com/Chanda-Abdul/Several-Coding-Patterns-for-Solving-Data-Structures-and-Algorithms-Problems-during-Interviews/blob/main/%E2%9C%85%20%F0%9F%99%83%20Pattern%2009:%20Two%20Heaps.md)

</details>

<details>
<summary>

#### Real World usage

</summary>

Two heaps approach is used when median calculation needed

- **Video platforms**: median age of the viewers
- **Gaming matchmaking**: Matching players of similar skill levels

</details>

## K-Way Merge

<AlgorithmSummary
  tc={{ latex: "$$O(n*log(k))$$" }}
  sc={{ latex: "$$O(k)$$" }}
/>

The **K-way merge** pattern combines **k** sorted data structures into a single **sorted** output.

It works by repeatedly selecting the smallest (or largest) element from among the first elements of each input list and adding it to the output list, continuing until all elements are merged in order.

K-way merge of sorted data could be achieved by:

- **Heaps**
- **Merge sort**

**Min Heap Approach**:

1. Insert first element from each list into min heap
2. Remove heap's top element, add to output
3. Replace with next element from same input list
4. Repeat until all elements merged

**Divide & Merge (merge sort)**:

1. Divide lists into 2 parts and merge each part
2. Continue dividing and merging resulting lists
3. Repeat until single sorted list remains

#### Typical problems

- <ProblemBadge difficulty="Medium" /> [378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/)
- <ProblemBadge difficulty="Medium" /> [373. Find K Pairs with Smallest Sums](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/)
- <ProblemBadge difficulty="Hard" /> [23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/description/)

#### When to use

- **Merging sorted arrays/matrix** rows/columns into a single sorted sequence
- **Finding kth smallest/largest** element across multiple sorted collections (like finding median in multiple sorted arrays)

<details>
<summary>

#### Problem examples

</summary>

<br />

<Problem
  title="378. Kth Smallest Element in a Sorted Matrix"
  link="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/"
  difficulty="Medium"
  example={{
    input: "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
    output: "13",
    explanation: "The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13"
  }}
>

Given an `n x n` matrix where each of the rows and columns is sorted in ascending order, return the <code>k<sub>th</sub></code> smallest element in the matrix.

Note that it is the <code>k<sub>th</sub></code> smallest element in the sorted order, not the <code>k<sub>th</sub></code> distinct element.

You must find a solution with a memory complexity better than $O(n^2)$.

</Problem>

```py filename="378. Kth Smallest Element in a Sorted Matrix"
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        min_heap = [(row[0], i, 0) for i, row in enumerate(matrix)]
        heapify(min_heap)

        while k:
            val, i, j = heappop(min_heap)
            k -= 1
            if j + 1 < len(matrix):
                heappush(min_heap, (matrix[i][j + 1], i, j + 1))

        return val
```

<ProblemComplexity tc="\(O(n*log(k))\)" sc="\(O(k)\)" />

---

<Problem
  title="373. Find K Pairs with Smallest Sums"
  link="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/"
  difficulty="Medium"
  example={{
    input: "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
    output: "[[1,2],[1,4],[1,6]]",
    explanation: "The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]"
  }}
>

You are given two integer arrays `nums1` and `nums2` sorted in non-decreasing order and an integer `k`.

Define a pair `(u, v)` which consists of one element from the first array and one element from the second array.

Return the `k` pairs <code>(u<sub>1</sub>, v<sub>1</sub>), (u<sub>2</sub>, v<sub>2</sub>), ..., (u<sub>k</sub>, v<sub>k</sub>)</code> with the **smallest sums**.

</Problem>

```py filename="373. Find K Pairs with Smallest Sums"
class Solution:
    def kSmallestPairs(
        self, nums1: List[int], nums2: List[int], k: int
    ) -> List[List[int]]:
        heap, seen, res = [(nums1[0] + nums2[0], 0, 0)], {(0, 0)}, []
        while heap and len(res) < k:
            _, i, j = heappop(heap)
            res.append([nums1[i], nums2[j]])
            for i2, j2 in [(i, j + 1), (i + 1, j)]:
                if i2 < len(nums1) and j2 < len(nums2) and (i2, j2) not in seen:
                    seen.add((i2, j2))
                    heappush(heap, (nums1[i2] + nums2[j2], i2, j2))
        return res
```

<ProblemComplexity tc="\(O(k*log(k))\)" sc="\(O(k)\)" />

---

<Problem
  title="23. Merge k Sorted Lists"
  link="https://leetcode.com/problems/merge-k-sorted-lists/description/"
  difficulty="Hard"
  example={{
    input: "lists = [[1,4,5],[1,3,4],[2,6]]",
    output: "[1,1,2,3,4,4,5,6]",
    explanation: <div>The linked-lists are:<br/>
  1-&gt;4-&gt;5<br/>
  1-&gt;3-&gt;4<br/>
  2-&gt;6<br/>
Merging them into one sorted list:<br/>
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
</div>
  }}
>

You are given an array of `k` linked-lists lists, each linked-list is sorted in ascending order.

Merge all the linked-lists into one sorted linked-list and return it.

</Problem>

```py filename="23. Merge k Sorted Lists"
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        head = cur = ListNode()
        heap = []
        for i, node in enumerate(lists):
            if not node:
                continue
            heappush(heap, (node.val, i))
        while heap:
            val, min_node_idx = heappop(heap)
            min_node = lists[min_node_idx]
            cur.next, cur = min_node, min_node
            if min_node.next:
                lists[min_node_idx] = min_node.next
                heappush(heap, (min_node.next.val, min_node_idx))
        return head.next
```

<ProblemComplexity tc="\(O(n*log(k))\)" sc="\(O(k)\)" />

</details>

<details>
<summary>

#### Additional materials

</summary>

- [Wikipedia - K-way merge algorithm](https://en.wikipedia.org/wiki/K-way_merge_algorithm)
- [Baeldung - 2-Way vs K-Way Merge](https://www.baeldung.com/cs/2-way-vs-k-way-merge)
- [Emre.me - K-way Merge](https://emre.me/coding-patterns/k-way-merge/)

</details>

<details>
<summary>

#### Real World usage

</summary>

- **Patient Records Aggregation**: In healthcare, integrating data from multiple sources like lab results and physician notes into a single record is vital. The K-way merge efficiently combines these data streams, aiding in diagnosis and treatment.

- **Financial Transaction Merging**: For financial institutions, merging transactions from different sources into a single stream is essential for analysis or fraud detection. K-way merge organizes these transactions coherently, improving financial monitoring and analysis.

- **Log File Analysis**: Web services generate logs from multiple servers. Merging these into one stream for analysis requires the K-way merge, making it easier to analyze user behavior or system performance with minimal preprocessing.

</details>

## Greedy

### Sometimes we can do the things retrospectively:

- [1642. Furthest Building You Can Reach](https://leetcode.com/problems/furthest-building-you-can-reach/description/) - Setting all the ladders and than retrospectively substitute them with bricks:

```py
class Solution:
    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:
        pq = []
        for i in range(len(heights) - 1):
            delta = heights[i + 1] - heights[i]
            if delta <= 0:
                continue
            if ladders:
                ladders -= 1
                heappush(pq, delta)
            elif bricks >= delta or (pq and bricks >= pq[0]):
                top = heappushpop(pq, delta)
                bricks -= top
            else:
                return i
        return len(heights) - 1
```

- [134. Gas Station](https://leetcode.com/problems/gas-station/) - On each iteration: Check the furthest you can go with current gas. Remember where max gas was. If current gas is empty, retrospectively load tank with gas from max station.

```py
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        cur_gas = 0
        total_gas = 0
        ans = 0
        for i in range(len(gas)):
            cur_gas += gas[i] - cost[i]
            total_gas += gas[i] - cost[i]
            if cur_gas < 0:
                cur_gas = 0
                ans = i + 1
        if total_gas < 0:
            return -1
        return ans
```

## Dijkstra's shortest path

#### Description

1. Set `distances` from initial node to each node: `0` to initial, `Infinity` to others
2. Init `Priority queue` `pq` to store potential min nodes
3. While `pq`:
   1. Pop nim node from `pq`
   2. Set all adjacent nodes `new distance = cur distance (it's minimal) + edge distances`. Set only if it's less than current adjacent node distance
   3. Add all adjacent nodes to `pq` with updated distances

#### Finding path

Backtrack from end node to start node:

1. On each iteration pick adjacent nodes to current
2. Set current to minimal
3. Add new node to result array
4. Return reversed array

Instead of backtracking, we can set `parent` nodes during main Dijkstra's algorithm. When it's finished:

1. Pick end node
2. Iteratively go to parent and remember current node (push it to result array)
3. return reversed array

## Dynamic Programming

Resources:

- [USACO Guide](https://usaco.guide/gold/intro-dp?lang=py)
- [Miro board with examples](https://miro.com/app/board/uXjVKsh2Zg4=/)

**Dynamic programming** is a computer programming technique where an algorithmic problem is first broken down into sub-problems, the results are saved, and then the sub-problems are optimized to find the overall solution.

#### Why use DP?

- The problem can be divided by subproblems
- The subproblems are overlapping

#### 3 main components:

1. **State** - stores answer for i-th subproblem
2. **Transition between states** - how to get new solution based on previously calculated
3. **Base case**

#### Approaches

- **Top-Down** - try to solve main problem first, and to solve it solve subproblems recursively up to base case
- **Bottom-Up** - solve subproblems starting from the next one to base case and finishing on main problem

---

- **Push DP** - update future states based on the current state
- **Pull DP** - calculate the current state based on past states

#### Top-Down vs Bottom-Up

**Top-Down**

- Benefits: Easier to implement because of recursion
- Drawbacks: Could not be appliciable because of call stack overflow

**Bottom-Up**

- Benefits: No recursion. Sometimes is better in space than Top-Down
- Drawbacks: Harder to implement

#### Hints on using DP

- Think of Base case
- First try recursive Top-Bottom
- Then if Top-Bottom doesn't fit (because of recursive stack or to optimise space, or whatsoever) then try Bottom-Up

## Traversals

1. **DFS** (Depth First Search) - search in depth

- **Preorder** - Used to clone tree
- **Inorder** - Used to travense tree in BFS order (when traversing over BST, print nodes in sorted order)
- **Postorder** - Used to delete tree

2. **BFS** (Breadth First Search) - search neighbors first
1. **DLS** (Depth Limited Search) - DFS but with limited depth
1. **IDDFS** (Iterative Deepening Depth First Search) - DLS with increasing depth limit (1, 2, 3, ...) until target is found

## Matrix

[Miro 🔗](https://miro.com/app/board/uXjVLeqOC3Q=/?share_link_id=441000358084)

**Problems with matrices**

1. Traverse in some order - [Spiral matrix](https://leetcode.com/problems/spiral-matrix-iv/description/)
2. Transform matrix - [Rotate image (matrix rotation)](https://leetcode.com/problems/rotate-image/description/)
3. Traverse on matrix as Graph (DFS, BFS, others) - [The Maze](https://leetcode.com/problems/the-maze/description/)
4. DP on matrix - [Maximal Square](https://leetcode.com/problems/maximal-square/description/)

## Bonus

### Greatest Common Divisor (GCD)

**Euclidean method** [🔗](https://en.wikipedia.org/wiki/Euclidean_algorithm)

This method is based on the principle:

> GCD doesn't change if we replace bigger number by difference of 2 numbers: `gcd(a, b) = gcd(a - b, b)`
> To make finding more efficient, `a - b` is changed to `a % b`:

<details>
<summary>

#### Problem examples

</summary>

<Problem
  title="2807. Insert Greatest Common Divisors in Linked List"
  link="https://leetcode.com/problems/insert-greatest-common-divisors-in-linked-list/description"
  difficulty="Medium"
>
Given the head of a linked list head, in which each node contains an integer value.

Between every pair of adjacent nodes, insert a new node with a value equal to the greatest common divisor of them.

Return the linked list after insertion.

The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.

</Problem>

<Image
  src="/algorithms-cheatsheet/2807.png"
  width="718"
  height="404"
  alt="Insert Greatest Common Divisors in Linked List example"
  priority={true}
/>

<br />

```py filename="2807. Insert Greatest Common Divisors in Linked List"
class Solution:
    def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def get_gcd(a, b):
            while b != 0:
                a, b = b, a % b
            return a
        cur = head
        while cur.next:
            gcd = get_gcd(cur.val, cur.next.val)
            cur.next = ListNode(gcd, cur.next)
            cur = cur.next.next
        return head
```

<ProblemComplexity tc="\(O(n \cdot \log(\min(a,b)))\)" sc="\(O(1)\)" />

</details>

### Prefix sums

#### When to use

- Find a number of continuous subarrays / submatrices / tree paths that sum to target paths that sum to target
  - <ProblemBadge difficulty="Medium" /> [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/description/)

### Time and Space Complexity. Big O notation
