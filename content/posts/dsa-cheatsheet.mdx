---
title: Algorithms and Data Structures Cheatsheet
description: A quick reference guide to some of the most commonly used algorithms in DSA
date: "2024-10-28"
---

<details>
<summary>

### Table of contents

</summary>

- [Two pointers](#two-pointers)
- [Sliding window](#sliding-window)
- [Intervals](#intervals)
- [Greedy](#greedy)
- [Dijkstra's shortest path](#dijkstras-shortest-path)
- [Dynamic Programming](#dynamic-programming)
- [Traversals](#traversals)
- [Matrix](#matrix)
- [Bonus](#bonus)

</details>

<details>
<summary>

### Definitions

</summary>

- **Search Space Tree** - tree of possible solutions generated on each iteration of algorithm. It's useful to think of your problem as Search-Space tree.

</details>

## Two pointers

<AlgorithmSummary tc={{ latex: "$$O(n)$$" }} sc={{ latex: "$$O(1)$$" }} />

Iterating two pointers across an array to search for a pair of indices satisfying some condition in linear time.

#### Types

- Opposite directional

  - <ProblemBadge difficulty="Medium" /> [167. Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/)
  - <ProblemBadge difficulty="Hard" /> [42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/description/)

- Same directional

  - <ProblemBadge difficulty="Easy" /> [26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)

- Fast and slow pointers
  - <ProblemBadge difficulty="Easy" /> [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/description/)
  - <ProblemBadge difficulty="Easy" /> [876. Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/description/)

#### When to use

- Sequential data structure (arrays, linked lists)
- Process pairs
- Remove duplicates from a sorted data
- Detect cycle in array
- Find a pair, triplet, or a subarray that satisfies a specific condition
- Reversing, partitioning, swapping, or rearranging
- String manipulation
- Array partitioning
- Etc. like Two sum or container with water variations

<details>
<summary>

#### Problem examples

</summary>

<br />

<Problem
  title="167. Two Sum II - Input Array Is Sorted"
  link="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description"
  difficulty="Medium"
>

Given a 1-indexed array of integers `numbers` that is already sorted in non-decreasing order, find two numbers such that they add up to a specific `target` number.

</Problem>

```py filename="167. Two Sum II - Input Array Is Sorted"
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        low = 0
        high = len(numbers) - 1
        while low < high:
            sum = numbers[low] + numbers[high]

            if sum == target:
                return [low + 1, high + 1]
            elif sum < target:
                low += 1
            else:
                high -= 1
        return [-1, -1]
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

---

<Problem
  title="876. Middle of the Linked List"
  link="https://leetcode.com/problems/middle-of-the-linked-list/description"
  difficulty="Easy"
>

Given the `head` of a singly linked list, return the middle node of the linked list.

If there are two middle nodes, return the second middle node.

</Problem>

```py filename="876. Middle of the Linked List"
class Solution:
    def middleNode(self, head):
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

---

<Problem
  title="42. Trapping Rain Water"
  link="https://leetcode.com/problems/trapping-rain-water/description"
  difficulty="Hard"
>

Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.

</Problem>

<Image
  src="/algorithms-cheatsheet/rain-water.png"
  width="718"
  height="404"
  alt="Trapping Rain Water example"
  priority={true}
/>

```py filename="42. Trapping Rain Water"
class Solution:
    def trap(self, height: List[int]) -> int:
        left, right = 0, len(height) - 1
        ans = 0
        left_max, right_max = 0, 0
        while left < right:
            if height[left] < height[right]:
                left_max = max(left_max, height[left])
                ans += left_max - height[left]
                left += 1
            else:
                right_max = max(right_max, height[right])
                ans += right_max - height[right]
                right -= 1
        return ans
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

</details>

<details>
<summary>

#### Additional materials

</summary>

- [Two Pointers Â· USACO Guide](https://usaco.guide/silver/two-pointers?lang=cpp)
- [Solved all two pointers problems in 100 days. - LeetCode Discuss](https://leetcode.com/discuss/study-guide/1688903/Solved-all-two-pointers-problems-in-100-days)
- [How to Solve Sliding Window Problems](https://medium.com/outco/how-to-solve-sliding-window-problems-28d67601a66)
- [Solved all two pointers problems in 100 days. - LeetCode Discuss](https://leetcode.com/discuss/study-guide/1688903/Solved-all-two-pointers-problems-in-100-days)
- [Algorithm Templates: Two Pointers](https://www.pluralsight.com/resources/blog/guides/algorithm-templates-two-pointers-part-1)
- [Two-Pointer Algorithm Explained: Practical Applications and Examples](<https://medium.com/@t.hasan.prince/two-pointer-algorithm-explained-practical-applications-and-examples-fc2c8bd137ca#:~:text=Array%20(%20path%20):%20This%20array,than%20targetSum%20%2C%20Alice%20moves%20forward.>)

</details>

## Sliding window

<AlgorithmSummary
  tc={{ latex: "$$O(n)$$" }}
  sc={{
    latex: (
      <ul>
        <li>\(O(1)\) if only 2 pointers tracked</li>
        <li>\(O(w)\) if window elements tracked</li>
      </ul>
    ),
  }}
/>

Maintain a **dynamic window** that slides through the array or string, adjusting its boundaries as needed to track relevant elements or characters.

Convert **multiple nested loops into single loop**, reducing the time complexity from $O(nÂ²)$ or $O(nÂ³)$ to $O(n)$.

#### Types

- **Fixed window size**
  - <ProblemBadge difficulty="Medium" /> [2461. Maximum Sum of Distinct Subarrays
    With Length K](https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/description/)
- **Variable window size**
  - Approach:
    - **Initialize window indices**: Start with `start` and `end` pointers at the first element.
    - **Expand the window**: Increment the `end` pointer to expand the window if conditions are met.
    - **Process the window**: Perform required operations when the window meets criteria.
    - **Adjust the window size**: Move the `start` pointer to adjust size and meet desired criteria.
  - <ProblemBadge difficulty="Medium" /> [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/description/)
- **Growing window**:
  - <ProblemBadge difficulty="Medium" /> [3. Longest Substring Without Repeating
    Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/)
  - <ProblemBadge difficulty="Medium" /> [904. Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/description/)
- **Shrinking window**
- **Multiple windows**: Maintaining overlapping or disjoint windows can help solve problems more efficiently.
  - <ProblemBadge difficulty="Hard" /> [992. Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/editorial/)

#### When to use

- **Contiguous** data: array, linked list, string, or stream
- Processing subsets of elements: The problem requires repeated computations on a **contiguous subset** of data elements (a subarray or a substring) of **fixed** or **variable** length
- Find longest, shortest or target values of a sequence

#### Problem patterns

1. **Running Average**: Efficiently calculate the average of a fixed-size window in a data stream.
1. **Formulating Adjacent Pairs**: Process adjacent pairs in an ordered structure for easy access and operation.
1. **Target Value Identification**: Adjust window size to search efficiently for specific values or subarrays.
1. **Longest/Shortest/Most Optimal Sequence**: Identify the desired sequence in a collection by sliding a window through it.

<details>
<summary>

#### Real World usage

</summary>

- **String Manipulation**:
  - Substring Search: Finding the longest substring without repeating characters.
  - Pattern Matching: Searching for a pattern within a larger string efficiently.
  - Text Processing: Analyzing text data for specific patterns or occurrences.
- **Array Manipulation**:
  - Subarray Problems: Finding the maximum sum, product, or average of a subarray of fixed or variable size.
  - Data Processing: Analyzing time series data, such as stock prices or sensor readings, to identify trends or anomalies.
- **Window-based Algorithms**:

  - Sliding Window Aggregations: Calculating moving averages, rolling sums, or other window-based aggregations in data analysis.
  - Stream Processing: Handling data streams by maintaining a sliding window over the stream to perform computations in real-time.

- **Data Compression**:
  - Sliding window compression algorithms, like [LZ77](https://en.wikipedia.org/wiki/LZ77_and_LZ78) and its variants, use a window to find repeated patterns in the input data and replace them with references to previous occurrences.
- **Image Processing**:
  - In image processing, a sliding window can be employed for tasks such as feature extraction, object detection, or image segmentation.
- **Signal Processing**:
  - Time-series data can be analyzed using a sliding window to capture local patterns, trends, or anomalies.
- **Network Traffic Analysis**:
  - Anomaly Detection: Identifying anomalous patterns in network traffic by analyzing data within sliding windows.
  - Performance Monitoring: Monitoring network performance metrics, such as latency or throughput, over time using sliding windows.
- **Optimization Problems**:
  - Resource Allocation: Optimizing resource allocation or scheduling decisions based on dynamic window-based constraints.
- **Natural Language Processing (NLP)**:
  - Text Classification: Analyzing text documents and classifying them into categories based on sliding window features.
  - Named Entity Recognition: Identifying entities such as names, locations, or organizations within text using sliding window-based algorithms.

</details>

<details>
<summary>

#### Problem examples

</summary>

<br />

<Problem 
  title="904. Fruit Into Baskets" 
  link="https://leetcode.com/problems/fruit-into-baskets/description/"
  difficulty="Medium"
  example={{
    input: "fruits = [0,1,2,2]",
    output: "3",
    explanation: "We can pick from trees [1,2,2]. If we had started at the first tree, we would only pick from trees [0,1]."
}}
>
You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array `fruits` where `fruits[i]` is the type of fruit the ith tree produces.

You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:

- You only have **two** baskets, and each basket can only hold a **single type** of fruit. There is **no limit** on the amount of fruit each basket can hold.
- **Starting from any tree** of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked `fruits` **must** fit in one of your baskets.
- Once you reach a tree with fruit that cannot fit in your baskets, you must **stop**.
- Given the integer array `fruits`, return the **maximum number** of `fruits` you can pick.

</Problem>

<Image
  src="/algorithms-cheatsheet/904.png"
  width="718"
  height="404"
  alt="Fruit Into Baskets Example"
  priority={true}
/>

Let's compare **Brute Force** approach with **Sliding window**.

In second approach, we **converted two nested loops into a single loop** thus improving Time Complexity from $O(n^2)$ to $O(n)$:

```py filename="904. Fruit Into Baskets. Brute Force approach"
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        max_picked = 0

        for left in range(len(fruits)):
            basket = set()
            right = left

            while right < len(fruits):
                if fruits[right] not in basket and len(basket) == 2:
                    break
                basket.add(fruits[right])
                right += 1

            max_picked = max(max_picked, right - left)
        return max_picked
```

<ProblemComplexity tc="\(O(n^2)\)" sc="\(O(1)\)" />

---

```py filename="904. Fruit Into Baskets. Sliding window approach"
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        basket = {}
        max_picked = 0
        left = 0

        for right in range(len(fruits)):
            basket[fruits[right]] = basket.get(fruits[right], 0) + 1

            while len(basket) > 2:
                basket[fruits[left]] -= 1
                if basket[fruits[left]] == 0:
                    del basket[fruits[left]]
                left += 1

            max_picked = max(max_picked, right - left + 1)
        return max_picked
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

---

<Problem 
  title="2461. Maximum Sum of Distinct Subarrays With Length K" 
  link="https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/description/"
  difficulty="Medium"
    example={{
    input: "nums = [1,5,4,2,9,9,9], k = 3",
    output: "15",
    explanation: "The subarray of length 3 with max sum of 15 is [4,2,9]"
}}
>
You are given an integer array `nums` and an integer `k`. Find the maximum subarray sum of all the subarrays of nums that meet the following conditions:

- The length of the subarray is `k`
- All the elements of the subarray are **distinct**.

Return the **maximum subarray sum** of all the subarrays that meet the conditions.
If no subarray meets the conditions, return **0**.

</Problem>

```py filename="2461. Maximum Sum of Distinct Subarrays With Length K"
class Solution:
    def maximum_subarray_sum(self, nums, k):
        res = cur_sum = 0
        last_seen_to_idx = {}
        last_seen = -1

        for i, num in enumerate(nums):
            cur_sum += num
            if i >= k:
                cur_sum -= nums[i - k]
            last_seen = max(last_seen, last_seen_to_idx.get(num, -1))
            if i - last_seen >= k:
                res = max(res, cur_sum)
            last_seen_to_idx[num] = i

        return res
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(n)\)" />

---

<Problem
  title="209. Minimum Size Subarray Sum"
  link="https://leetcode.com/problems/minimum-size-subarray-sum/description"
  difficulty="Medium"
  example={{
    input: "target = 7, nums = [2,3,1,2,4,3]",
    output: "2",
    explanation:
      "The subarray [4,3] has the minimal length under the problem constraint.",
  }}
>
  Given an array of positive integers `nums` and a positive integer `target`,
  return the minimal length of a subarray whose sum is greater than or equal to
  `target`. If there is no such subarray, return `0` instead.
</Problem>

```py filename="209. Minimum Size Subarray Sum"
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        left = 0
        right = 0
        sumOfCurrentWindow = 0
        res = float('inf')

        for right in range(0, len(nums)):
            sumOfCurrentWindow += nums[right]

            while sumOfCurrentWindow >= target:
                res = min(res, right - left + 1)
                sumOfCurrentWindow -= nums[left]
                left += 1

        return res if res != float('inf') else 0
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

---

<Problem
  title="1456. Maximum Number of Vowels in a Substring of Given Length"
  link="https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/"
  difficulty="Medium"
  example={{
    input: "s = \"abciiidef\", k = 3",
    output: "3",
    explanation:
      "The substring \"iii\" contains 3 vowel letters.",
  }}
>

Given a string `s` and an integer `k`, return the maximum number of vowel letters in any substring of s with length `k`.

</Problem>

```py filename="1456. Maximum Number of Vowels in a Substring of Given Length"
class Solution:
    def maxVowels(self, s: str, k: int) -> int:
        vowels = set("aeiou")
        count = 0
        for i in range(k):
            count += int(s[i] in vowels)
        answer = count
        for i in range(k, len(s)):
            count += int(s[i] in vowels)
            count -= int(s[i - k] in vowels)
            answer = max(answer, count)

        return answer
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(1)\)" />

</details>

<details>
<summary>

#### Additional materials

</summary>

- [Sliding Window - USACO Guide](https://usaco.guide/gold/sliding-window?lang=py)
- [Mastering Sliding Window Techniques | by Ankit Singh | Medium](https://medium.com/@rishu__2701/mastering-sliding-window-techniques-48f819194fd7)
- [Sliding Window Technique: A Comprehensive Guide - LeetCode Discuss](https://leetcode.com/discuss/interview-question/3722472/mastering-sliding-window-technique-a-comprehensive-guide)

</details>

## Intervals

<AlgorithmSummary tc={{ latex: "$$O(n)$$" }} sc={{ latex: "$$O(1)$$" }} />

Typical interval problem deals with **array of overlapping intervals** e.g. `[[1, 3], [3, 5]]`

Common tasks with intervals:

- Merging intersecting intervals
  - <ProblemBadge difficulty="Medium" /> [https://leetcode.com/problems/merge-intervals/description/](https://leetcode.com/problems/merge-intervals/description/)
- Inserting new intervals into existing sets
  - <ProblemBadge difficulty="Medium" /> [57. Insert Interval](https://leetcode.com/problems/insert-interval/description/)
- Schedule tasks
  - <ProblemBadge difficulty="Medium" /> [621. Task Scheduler](https://leetcode.com/problems/task-scheduler/description/)
- Arrange meeting rooms
  - <ProblemBadge difficulty="Medium" /> [253. Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/description/)
- Determining the minimum number of intervals needed to cover a given range

#### Corner cases

- No intervals
- Single interval
- Two intervals
- Non-overlapping intervals
- An interval totally consumed within another interval
- Duplicate intervals (exactly the same start and end)
- Intervals which start right where another interval ends - `[[1, 2], [2, 3]]`

#### When to use

- Given intervals
- Find union / intersection / gaps

<details>
<summary>

#### Real World usage

</summary>

- **Event scheduling**
- **Resource allocation**: Schedule tasks for the OS based on task priority and the free slots in the machineâ€™s processing schedule
- **Time slot consolidation**

</details>
<details>
<summary>
#### Problem examples

</summary>

<br />

<Problem
  title="56. Merge Intervals"
  link="https://leetcode.com/problems/merge-intervals/description/"
  difficulty="Medium"
  example={{
    input: "intervals = [[1,3], [2,6], [8,10], [15,18]]",
    output: "[[1,6], [8,10], [15,18]]",
    explanation: "Since intervals [1,3] and [2,6] overlap, merge them into [1,6].",
  }}
>

Given an array of intervals where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.

</Problem>

```py filename="56. Merge Intervals"
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key=lambda x: x[0])
        merged = []

        for interval in intervals:
            if not merged or merged[-1][1] < interval[0]:
                merged.append(interval)
            else:
                merged[-1][1] = max(merged[-1][1], interval[1])

        return merged
```

<ProblemComplexity
  tc="\(O(n*log(n))\)"
  sc="\(O(n)\) or \(O(log(n))\) depending on sorting algorithm"
/>

---

<Problem
  title="57. Insert Interval"
  link="https://leetcode.com/problems/insert-interval/description/"
  difficulty="Medium"
    example={{
    input: "intervals = [[1,2], [3,5], [6,7], [8,10], [12,16]], newInterval = [4,8]",
    output: "[[1,2], [3,10], [12,16]]",
    explanation: "Because the new interval [4,8] overlaps with [3,5], [6,7], [8,10].",
  }}
>

You are given an array of non-overlapping intervals `intervals` where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> represent the start and the end of the <code>i<sup>th</sup></code> interval and `intervals` is sorted in ascending order by <code>start<sub>i</sub></code>. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval.

Insert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by <code>start<sub>i</sub></code> and `intervals` still does not have any overlapping intervals (**merge** overlapping intervals if necessary).

Return intervals after the insertion.

Note that you don't need to modify intervals in-place. You can make a new array and return it.

</Problem>

Problem can be dropped down into 2 subproblems:

1. Find correct place for `newInterval`
   - Since `intervals` is sorted, we can utilize binary search.
2. Merge it with any overlapping intervals
   - Linear iteration over intervals

```py filename="57. Insert Interval"
class Solution:
    def insert(
        self, intervals: List[List[int]], newInterval: List[int]
    ) -> List[List[int]]:
        # If the intervals vector is empty, return a vector containing the newInterval
        if not intervals:
            return [newInterval]

        n = len(intervals)
        target = newInterval[0]
        left, right = 0, n - 1

        # Binary search to find the position to insert newInterval
        while left <= right:
            mid = (left + right) // 2
            if intervals[mid][0] < target:
                left = mid + 1
            else:
                right = mid - 1

        # Insert newInterval at the found position
        intervals.insert(left, newInterval)

        # Merge overlapping intervals
        res = []
        for interval in intervals:
            # If res is empty or there is no overlap, add the interval to the result
            if not res or res[-1][1] < interval[0]:
                res.append(interval)
            # If there is an overlap, merge the intervals by updating the end of the last interval in res
            else:
                res[-1][1] = max(res[-1][1], interval[1])
        return res
```

<ProblemComplexity tc="\(O(n)\)" sc="\(O(n)\)" />

---

<Problem
  title="621. Task Scheduler"
  link="https://leetcode.com/problems/task-scheduler/description/"
  difficulty="Medium"
  example={{
    input: `tasks = ["A","A","A","B","B","B"], n = 2`,
    output: "8",
    explanation: <span>A possible sequence is: <code>A â†’ B â†’ idle â†’ A â†’ B â†’ idle â†’ A â†’ B</code>.<br/> After completing task <i>A</i>, you must wait two intervals before doing <i>A</i> again. The same applies to task <i>B</i>. In the 3 interval, neither <i>A</i> nor <i>B</i> can be done, so you <i>idle</i>. By the 4 interval, you can do <i>A</i> again as 2 intervals have passed.</span>
}}

>

You are given an array of CPU `tasks`, each labeled with a letter from A to Z, and a number `n`. Each CPU interval can be idle or allow the completion of one task. Tasks can be completed in any order, but there's a **constraint**:
There has to be a gap of at least `n` intervals between two tasks with the same label.

Return the **minimum number** of CPU intervals required to complete all `tasks`.

</Problem>

```py filename="621. Task Scheduler"
class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        counter = Counter(tasks)
        max_heap = [-val for val in counter.values()]
        heapify(max_heap)
        res = 0
        while max_heap:
            cycle = n + 1
            tasks = []
            while cycle and max_heap:
                task = -heappop(max_heap)
                cycle -= 1
                if task > 1:
                    tasks.append(-(task - 1))
            while tasks:
                heappush(max_heap, tasks.pop())
            res += n + 1 if max_heap else n - cycle + 1

        return res
```

<ProblemComplexity
  tc="\(O(n*log(26)) \rightarrow O(n)\)"
  sc="\(O(26) \rightarrow O(1)\)"
/>

---

<Problem
  title="253. Meeting Rooms II"
  link="https://leetcode.com/problems/meeting-rooms-ii/description/"
  difficulty="Medium"
>

Given an array of meeting time intervals `intervals` where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, return the **minimum number of conference rooms** required.

</Problem>

```py filename="253. Meeting Rooms II"
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        intervals.sort()
        end_times = []
        for start, end in intervals:
            if not end_times or end_times[0] > start:
                heapq.heappush(end_times, end)
            else:
                heapq.heapreplace(end_times, end)

        return len(end_times)
```

<ProblemComplexity tc="\(O(n*log(n))\)" sc="\(O(n)\)" />

</details>

<details>
<summary>

#### Additional materials

</summary>

- [Interval cheatsheet for coding interviews](https://www.techinterviewhandbook.org/algorithms/interval/)
- [Merge Intervals](https://www.educative.io/courses/grokking-coding-interview/merge-intervals)

</details>

## Greedy

### Sometimes we can do the things retrospectively:

- [1642. Furthest Building You Can Reach](https://leetcode.com/problems/furthest-building-you-can-reach/description/) - Setting all the ladders and than retrospectively substitute them with bricks:

```py
class Solution:
    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:
        pq = []
        for i in range(len(heights) - 1):
            delta = heights[i + 1] - heights[i]
            if delta <= 0:
                continue
            if ladders:
                ladders -= 1
                heappush(pq, delta)
            elif bricks >= delta or (pq and bricks >= pq[0]):
                top = heappushpop(pq, delta)
                bricks -= top
            else:
                return i
        return len(heights) - 1
```

- [134. Gas Station](https://leetcode.com/problems/gas-station/) - On each iteration: Check the furthest you can go with current gas. Remember where max gas was. If current gas is empty, retrospectively load tank with gas from max station.

```py
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        cur_gas = 0
        total_gas = 0
        ans = 0
        for i in range(len(gas)):
            cur_gas += gas[i] - cost[i]
            total_gas += gas[i] - cost[i]
            if cur_gas < 0:
                cur_gas = 0
                ans = i + 1
        if total_gas < 0:
            return -1
        return ans
```

## Dijkstra's shortest path

#### Description

1. Set `distances` from initial node to each node: `0` to initial, `Infinity` to others
2. Init `Priority queue` `pq` to store potential min nodes
3. While `pq`:
   1. Pop nim node from `pq`
   2. Set all adjacent nodes `new distance = cur distance (it's minimal) + edge distances`. Set only if it's less than current adjacent node distance
   3. Add all adjacent nodes to `pq` with updated distances

#### Finding path

Backtrack from end node to start node:

1. On each iteration pick adjacent nodes to current
2. Set current to minimal
3. Add new node to result array
4. Return reversed array

Instead of backtracking, we can set `parent` nodes during main Dijkstra's algorithm. When it's finished:

1. Pick end node
2. Iteratively go to parent and remember current node (push it to result array)
3. return reversed array

## Dynamic Programming

Resources:

- [USACO Guide](https://usaco.guide/gold/intro-dp?lang=py)
- [Miro board with examples](https://miro.com/app/board/uXjVKsh2Zg4=/)

**Dynamic programming** is a computer programming technique where an algorithmic problem is first broken down into sub-problems, the results are saved, and then the sub-problems are optimized to find the overall solution.

#### Why use DP?

- The problem can be divided by subproblems
- The subproblems are overlapping

#### 3 main components:

1. **State** - stores answer for i-th subproblem
2. **Transition between states** - how to get new solution based on previously calculated
3. **Base case**

#### Approaches

- **Top-Down** - try to solve main problem first, and to solve it solve subproblems recursively up to base case
- **Bottom-Up** - solve subproblems starting from the next one to base case and finishing on main problem

---

- **Push DP** - update future states based on the current state
- **Pull DP** - calculate the current state based on past states

#### Top-Down vs Bottom-Up

**Top-Down**

- Benefits: Easier to implement because of recursion
- Drawbacks: Could not be appliciable because of call stack overflow

**Bottom-Up**

- Benefits: No recursion. Sometimes is better in space than Top-Down
- Drawbacks: Harder to implement

#### Hints on using DP

- Think of Base case
- First try recursive Top-Bottom
- Then if Top-Bottom doesn't fit (because of recursive stack or to optimise space, or whatsoever) then try Bottom-Up

## Traversals

1. **DFS** (Depth First Search) - search in depth

- **Preorder** - Used to clone tree
- **Inorder** - Used to travense tree in BFS order (when traversing over BST, print nodes in sorted order)
- **Postorder** - Used to delete tree

2. **BFS** (Breadth First Search) - search neighbors first
1. **DLS** (Depth Limited Search) - DFS but with limited depth
1. **IDDFS** (Iterative Deepening Depth First Search) - DLS with increasing depth limit (1, 2, 3, ...) until target is found

## Matrix

[Miro ðŸ”—](https://miro.com/app/board/uXjVLeqOC3Q=/?share_link_id=441000358084)

**Problems with matrices**

1. Traverse in some order - [Spiral matrix](https://leetcode.com/problems/spiral-matrix-iv/description/)
2. Transform matrix - [Rotate image (matrix rotation)](https://leetcode.com/problems/rotate-image/description/)
3. Traverse on matrix as Graph (DFS, BFS, others) - [The Maze](https://leetcode.com/problems/the-maze/description/)
4. DP on matrix - [Maximal Square](https://leetcode.com/problems/maximal-square/description/)

## Bonus

### Greatest Common Divisor (GCD)

**Euclidean method** [ðŸ”—](https://en.wikipedia.org/wiki/Euclidean_algorithm)

This method is based on the principle:

> GCD doesn't change if we replace bigger number by difference of 2 numbers: `gcd(a, b) = gcd(a - b, b)`
> To make finding more efficient, `a - b` is changed to `a % b`:

<details>
<summary>

#### Problem examples

</summary>

<Problem
  title="2807. Insert Greatest Common Divisors in Linked List"
  link="https://leetcode.com/problems/insert-greatest-common-divisors-in-linked-list/description"
  difficulty="Medium"
>
Given the head of a linked list head, in which each node contains an integer value.

Between every pair of adjacent nodes, insert a new node with a value equal to the greatest common divisor of them.

Return the linked list after insertion.

The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.

</Problem>

<Image
  src="/algorithms-cheatsheet/2807.png"
  width="718"
  height="404"
  alt="Insert Greatest Common Divisors in Linked List example"
  priority={true}
/>

<br />

```py filename="2807. Insert Greatest Common Divisors in Linked List"
class Solution:
    def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def get_gcd(a, b):
            while b != 0:
                a, b = b, a % b
            return a
        cur = head
        while cur.next:
            gcd = get_gcd(cur.val, cur.next.val)
            cur.next = ListNode(gcd, cur.next)
            cur = cur.next.next
        return head
```

<ProblemComplexity tc="\(O(n \cdot \log(\min(a,b)))\)" sc="\(O(1)\)" />

</details>

### Prefix sums

#### When to use

- Find a number of continuous subarrays / submatrices / tree paths that sum to target paths that sum to target
  - <ProblemBadge difficulty="Medium" /> [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/description/)

### Time and Space Complexity. Big O notation
